### 1.线程的几个状态

#### 从 操作系统层面来描述的五种状态

![image-20200919203847366](G:\soft\Typora\img\image-20200919203847366.png)

【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联
【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行
【运行状态】指获取了 CPU 时间片运行中的状态
当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换
【阻塞状态】
如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入
【阻塞状态】
等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】
与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑
调度它们
【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态  



从 Java API 层面来描述的 （六种状态）

![image-20200919203943433](G:\soft\Typora\img\image-20200919203943433.png)

NEW 线程刚被创建，但是还没有调用 start() 方法
RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的
【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为
是可运行）
BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，
TERMINATED 当线程代码运行结束  

###  2.怎么进入阻塞状态

- 该线程调用wait(),sleep()，join()方法
- 线程在synchronized同步代码块竞争对象锁失败，进入等待队列

###  3.死锁

**死锁的定义：**死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

死锁产生的条件：

![image-20200919205123790](G:\soft\Typora\img\image-20200919205123790.png)

###  4.新生代内的GC说一下

新生代分为一个Eden和两个survivor空间，因为新生代的对象都是**朝生夕死**。所以采用复制算法实现垃圾回收，通过可达性分析法判断Eden和From-Survivor空间中还存活的对象，将其复制到To-Survivor空间，如果还存活的对象所需空间大于To-survivor空间大小，那么这些对象将会通过分配担保机制进入老年区。

###  5.什么情况下新生代的gc会很慢

 1、新生代空间设置过大。 

  2、 对象引用链较长，进行可达性分析时间较长。 

  3、 新生代survivor区设置的比较小，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销。 

  4、 内存分配担保失败，由minor gc转化为full gc 

  5、 采用的垃圾收集器效率较低，比如新生代使用serial收集器

### 6.内存泄漏的情况

https://blog.csdn.net/weter_drop/article/details/89387564

###  7.B+树的结构和优点

![img](https://img1.sycdn.imooc.com/5bdeffab0001db6b19961014.jpg)

### **优点**

1. 单次请求涉及的磁盘IO次数少（出度d大，且非叶子节点不包含表数据，树的高度小）；
2. 查询效率稳定（任何关键字的查询必须走从根结点到叶子结点，查询路径长度相同）；
3. 遍历效率高（从符合条件的某个叶子节点开始遍历即可）；



mysql索引

使用B+树结构,一个节点存放1170个索引

1个节点  16k 

索引8b+地址6b，     16k/14B = 1170

###  8.BlockingQueue

<https://www.jianshu.com/p/7b2f1fa616c6>

###  9.队列的实现

<https://blog.csdn.net/devnn/article/details/82716447?utm_medium=distribute.pc_relevant.none-task-blog-title-1&spm=1001.2101.3001.4242>

###  10.设计一个连接池（连接池有什么好处）

#### 1． 资源重用 

由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增进了系统运行环境的平稳性（减少内存碎片以及数据库临时进程/线程的数量）。 

#### 2． 更快的系统响应速度 

数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。 

#### 3． 新的资源分配手段 

对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接的配置，使用数据库连接池技术。设置某一应用最大可用数据库连接数，避免某一应用独占所有数据库资源。 

#### 4． 统一的连接管理，避免数据库连接泄漏 

在较为完备的数据库连接池实现中，可根据预先设定的连接占用超时时间，强制收回被超时占用的连接。从而避免了常规数据库连接操作中可能出现的资源泄漏（当程序存在缺陷时，申请的连接忘记关闭，这时候，就存在连接泄漏）