# 1.动态代理一般有哪几种实现方式？动态代理的应用场景有哪些？

1.jdk动态代理

2.cglib动态代理

应用场景如：

- 统计每个 api 的请求耗时
- 统一的日志输出
- 校验被调用的 api 是否已经登录和权限鉴定
- Spring的 AOP 功能模块就是采用动态代理的机制来实现切面编程



# 2.如何实现不可变的类？



1）类声明为final，不可以被继承
2）所有成员是私有的，不允许直接被访问
3）对变量不要setter方法
4）所有可变的变量是final的，只能赋值一次
5）通过构造器初始化所有成员，进行深拷贝
6）在getter方法中不能返回对象本身，返回对象的拷贝



# 3.浅复制和深复制？怎样实现深复制？

- 浅拷贝：使用一个已知实例对新创建实例的成员变量逐个 **赋值**，这个方式被称为浅拷贝。
- 深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新的实例，并且初始化为形式参数实例值。



**实现Cloneable 接口**

**实现Serializable 接口**

拷贝时调用SerializationUtils.clone()方法;

**使用Jackson序列化**
使用Jackson序列化成string，再反序列化成对象（需要提供无参的构造器）





# 4.HashMap、 HashTable、 ConcurrentHashMap 的区别？

HashMap 线程不安全     1.7  数组+链表  1.8 数组+链表+红黑树

默认容量16  负载因子 0.75  扩容 2倍

默认容量为2的幂时，上述n -1 对应的二进制数全为1，这样才能保证它和key的hashcode做&运算后，能够**均匀分布**，这样才能减少hash碰撞的次数

HashTable 线程安全   Synchronized实现

ConcurrentHashMap 线程安全  分段锁 segment 实现





# 5.CAS 是一种什么样的同步机制？

cas （compare and set/swap) 非阻塞同步机制

CAS的缺点：

1.CPU开销较大

在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。

2.不能保证代码块的原子性

CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。

3.ABA问题

这是CAS机制最大的问题所在。

现代的处理器都包含对并发的支持，其中最通用的方法就是比较并交换（compare and swap），简称CAS。

compareAndSet调用了unsafe.compareAndSwapInt，这是一个native方法，原理就是调用硬件支持的CAS方法。



# 6.简单介绍一下 java 的反射机制？反射在哪些地方有应用场景？

Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的以及动态调用对象的方法的功能称为Java的反射机制。

- 逆向代码 ，例如反编译
- 与注解相结合的框架 例如Retrofit
- 单纯的反射机制应用框架 例如EventBus 2.x
- 动态生成类框架 例如Gson