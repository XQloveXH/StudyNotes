# Class类文件结构

实现语言无关性的基础仍然是虚拟机和字节码存储格式。 Java虚拟机不与包括Java语言在内的任何
程序语言绑定， 它只与“Class文件”这种特定的二进制文件格式所关联， Class文件中包含了Java虚拟机
指令集、 符号表以及若干其他辅助信息。 

Java语言中的各种语法、 关键字、 常量变量和运算符号的语义最终都会由多条字节码指令组合来
表达， 这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行。   

![1604714377987](E:\soft\Typora\img\1604714377987.png)

## 定义

**Class文件是一组以8个字节为基础单位的二进制流， 各个数据项目严格按照顺序紧凑地排列在文**
**件之中， 中间没有添加任何分隔符**， 这使得整个Class文件中存储的内容几乎全部是程序运行的必要数
据， 没有空隙存在。 当遇到需要占用8个字节以上空间的数据项时， 则会按照高位在前[2]的方式分割
成若干个8个字节进行存储。 

## 文件格式

Class文件格式采用一种类似于C语言结构体的伪结构来存储数据， 这种伪结构中只有两种数据类型： **“无符号数”和“表”**。  

### 无符号数

无符号数属于基本的数据类型， 以u1、 u2、 u4、 u8来分别代表1个字节、 2个字节、 4个字节和8个字节的无符号数， 无符号数可以用来描述数字、 索引引用、 数量值或者按照UTF-8编码构成字符串值 

### 表

**表是由多个无符号数或者其他表作为数据项构成的复合数据类型**， 为了便于区分， 所有表的命名
都习惯性地以“_info”结尾。 表用于描述有层次关系的复合结构的数据， 整个Class文件本质上也可以视
作是一张表， 这张表由表6-1所示的数据项按严格顺序排列构成。 

![1604714609937](E:\soft\Typora\img\1604714609937.png)





# 魔数与Class文件的版本 

每个Class文件的头4个字节被称为**魔数**（Magic Number） ， 它的唯一作用是**确定这个文件是否为一个能被虚拟机接受的Class文件。** 

紧接着魔数的4个字节存储的是Class文件的版本号： **第5和第6个字节是次版本号**（MinorVersion） ， 第**7和第8个字节是主版本号**（Major Version）  

# 常量池 

紧接着主、 次版本号之后的是常量池入口， **常量池可以比喻为Class文件里的资源仓库**， 它是Class
文件结构中与其他项目关联最多的数据， **通常也是占用Class文件空间最大的数据项目之一**， 另外， 它
还是在Class文件中第一个出现的表类型数据项目。 

**常量池中主要存放两大类常量： 字面量（Literal） 和符号引用（Symbolic References）** 

## 字面量 

字面量比较接近于Java语言层面的常量概念， 如文本字符串、 被声明为final的常量值等 

## 符号引用

- 被模块导出或者开放的包（Package）
- 类和接口的全限定名（Fully Qualified Name）
- 字段的名称和描述符（Descriptor）
- 方法的名称和描述符
- 方法句柄和方法类型（Method Handle、 Method Type、 Invoke Dynamic）
- 动态调用点和动态常量（Dynamically-Computed Call Site、 Dynamically-Computed Constant） 

Java代码在进行Javac编译的时候， 并不像C和C++那样有“连接”这一步骤， 而是在虚拟机加载Class文件的时候进行动态连接（具体见第7章） 。 也就是说， **在Class文件中不会保存各个方法、 字段最终在内存中的布局信息， 这些字段、 方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址， 也就无法直接被虚拟机使用的。 当虚拟机做类加载时， 将会从常量池获得对应的符号引用， 再在类创建时或运行时解析、 翻译到具体的内存地址之中。**  

## 常量池的项目类型

![1604715711444](E:\soft\Typora\img\1604715711444.png)



## 常量池中的17种数据结构

![1604716323798](E:\soft\Typora\img\1604716323798.png)

![1604716290990](E:\soft\Typora\img\1604716290990.png)

![1604716303797](E:\soft\Typora\img\1604716303797.png)

# 访问标志 

在常量池结束之后， 紧接着的2个字节代表访问标志（access_flags） ， 这个标志**用于识别一些类或者接口层次的访问信息**， 包括： 这个Class是类还是接口； 是否定义为public类型； 是否定义为abstract类型； 如果是类的话， 是否被声明为final；  

![1604716476781](E:\soft\Typora\img\1604716476781.png)



# 类索引、 父类索引与接口索引集合 

类索引（this_class） 和父类索引（super_class） 都是一个u2类型的数据， 而接口索引集合（interfaces） 是一组u2类型的数据的集合， **Class文件中由这三项数据来确定该类型的继承关系。 类索引用于确定这个类的全限定名， 父类索引用于确定这个类的父类的全限定名。**

由于Java语言不允许多重继承， 所以父类索引只有一个， 除了java.lang.Object之外， 所有的Java类都有父类， 因此除了java.lang.Object外， 所有Java类的父类索引都不为0。 接口索引集合就用来描述这个类实现了哪些接口， 这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口， 则应当是extends关键字） 后的接口顺序从左到右排列在接口索引集合中  

### 类索引查找全限定名

类索引、 父类索引和接口索引集合都按顺序排列在访问标志之后， 类索引和父类索引用两个u2类型的索引值表示， 它们各自指向一个类型为CONSTANT_Class_info的类描述符常量， 通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。 图6-6演示了代码清单6-1中代码的**类索引查找过程** 

![1604716663798](E:\soft\Typora\img\1604716663798.png)

# 字段表集合 

**字段表（field_info） 用于描述接口或者类中声明的变量** ，包括类级变量以及实例级变量， 但不包括在方法内部声明的局部变量。 

## 字段表结构

![1604716944811](E:\soft\Typora\img\1604716944811.png)

### access_flags 

是一个u2的数据类型， 其中可以设置的标志位和含义如表6-9所示。 

### ![1604716975399](E:\soft\Typora\img\1604716975399.png)

### name_index 

代表着字段的简单名称 ，

**简单名称则就是指没有类型和参数修饰的方法或者字段名称**， 这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。 

### descriptor_index 

#### **描述符的作用是用来描述字段的数据类型、 方法的参数列表（包括数量、 类型以及顺序） 和返回值。** 

![1604717165825](E:\soft\Typora\img\1604717165825.png)

#### 数组和方法的描述

**对于数组类型， 每一维度将使用一个前置的“[”字符来描述**， 如一个定义为“java.lang.String[][]”类型
的二维数组将被记录成“[[Ljava/lang/String； ”， 一个整型数组“int[]”将被记录成“[I”。

**用描述符来描述方法时， 按照先参数列表、 后返回值的顺序描述**， 参数列表按照参数的严格顺序
放在一组小括号“()”之内。 如方法void inc()的描述符为“()V”， 方法java.lang.String toString()的描述符
为“()Ljava/lang/String； ”， 方法int indexOf(char[]source， int sourceOffset， int sourceCount， char[]target，int targetOffset， int targetCount， int fromIndex)的描述符为“([CII[CIII)I”。 

### 属性表

**字段表所包含的固定数据项目到descriptor_index为止就全部结束了**， 不过在descrip-tor_index之后
跟随着一个属性表集合， 用于存储一些额外的信息， 字段表可以在属性表中附加描述零至多项的额外
信息。 对于本例中的字段m， 它的属性表计数器为0， 也就是没有需要额外描述的信息， 但是， 如果将
字段m的声明改为“final static int m=123； ”， 那就可能会存在一项名称为ConstantValue的属性， 其值指
向常量123。 关于attribute_info的其他内容， 将在6.3.7节介绍属性表的数据项目时再做进一步讲解。

**字段表集合中不会列出从父类或者父接口中继承而来的字段， 但有可能出现原本Java代码之中不存在的字段**，譬如在内部类中为了保持对外部类的访问性， 编译器就会自动添加指向外部类实例的字段。 另外， 在Java语言中字段是无法重载的， 两个字段的数据类型、 修饰符不管是否相同， 都必须使用不一样的名称， 但是对于Class文格式来讲， 只要两个字段的描述符不是完全相同， 那字段重名就是合法的 

# 方法表集合 

![1604717730124](E:\soft\Typora\img\1604717730124.png)



因为volatile关键字和transient关键字不能修饰方法， 所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。 与之相对， synchronized、 native、 strictfp和abstract关键字可以修饰方法， 方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、ACC_NATIVE、 ACC_STRICTFP和ACC_ABSTRACT标志。 对于方法表， 所有标志位及其取值可参见表6-12。 

![1604717780716](E:\soft\Typora\img\1604717780716.png)

### code属性

**方法里的Java代码， 经过Javac编译器编译成字节码指令之后， 存放在方法属性表集合中一个名为“Code”的属性里面， 属性表作为Class文件格式中最具扩展性的一种数据项目， 将在下一节中详细讲解。** 

### 重载

与字段表集合相对应地， **如果父类方法在子类中没有被重写（Override） ， 方法表集合中就不会出**
**现来自父类的方法信息**。 但同样地， 有可能会出现由编译器自动添加的方法， 最常见的便是类构造
器“<clinit>()”方法和实例构造器“<init>()”方法[1]。

在Java语言中， 要重载（Overload） 一个方法， 除了要与原方法具有相同的简单名称之外， 还要求必须拥有一个与原方法不同的特征签名[2]。 特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合， 也正是因为返回值不会包含在特征签名之中， 所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。 但是在Class文件格式之中， 特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。 也就是说， **如果两个方法有相同的名称和特征签名， 但返回值不同， 那么也是可以合法共存于同一个Class文件中的。** 

在《Java虚拟机规范》 第2版的4.4.4节及《Java语言规范》 第3版的8.4.2节中分别都定义了字节码层面的方法特征签名以及Java代码层面的方法特征签名， **Java代码的方法特征签名只包括方法名称、 参数顺序及参数类型， 而字节码的特征签名还包括方法返回值以及受查异常表， 请读者根据上下文语境注意区分。** 

# 属性表

属性表（attribute_info） 在前面的讲解之中已经出现过数次**， Class文件、 字段表、 方法表都可以携带自己的属性表集合， 以描述某些场景专有的信息。** 

![1604718118942](E:\soft\Typora\img\1604718118942.png)

![1604718129334](E:\soft\Typora\img\1604718129334.png)

![1604718154428](E:\soft\Typora\img\1604718154428.png)

![1604718172302](E:\soft\Typora\img\1604718172302.png)

![1604718268599](E:\soft\Typora\img\1604718268599.png)

## Code属性

**Java程序方法体里面的代码经过Javac编译器处理之后， 最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中**， 但并非所有的方法表都必须存在这个属性， 譬如接口或者抽象类中的方法就不存在Code属性， 如果方法表有Code属性存在， 那么它的结构将如表6-15所示。 

![1604718334756](E:\soft\Typora\img\1604718334756.png)

### attribute_name_index 

attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引， 此常量值固定为“Code”， 它
代表了该属性的属性名称 

### attribute_length 

attribute_length指示了属性值的长度， 由于属性名称索引与属性长度一共为6个字节， 所以属性值的长度固定为整个属性表长度减去6个字节。 

### max_stack 

**max_stack代表了操作数栈（Operand Stack） 深度的最大值**。 在方法执行的任意时刻， 操作数栈都不会超过这个深度。 虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame） 中的操作栈深度。 

### max_locals

**max_locals代表了局部变量表所需的存储空间**。 在这里， max_locals的单位是变量槽（Slot） ， 变量槽是虚拟机为局部变量分配内存所使用的最小单位。

## code和异常表（try-catch原理）

![1604718804508](E:\soft\Typora\img\1604718804508.png)  	



**编译器为这段Java源码生成了三条异常表记录， 对应三条可能出现的代码执行路径**。 从Java代码的
语义上讲， 这三条执行路径分别为：

- **如果try语句块中出现属于Exception或其子类的异常， 转到catch语句块处理；**
- **如果try语句块中出现不属于Exception或其子类的异常， 转到finally语句块处理；**
- **如果catch语句块中出现任何异常， 转到finally语句块处理** 

## Exceptions属性 

这里的Exceptions属性是在方法表中与Code属性平级的一项属性， 读者不要与前面刚刚讲解完的异常表产生混淆。 **Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons） ， 也就是方法描述时在throws关键字后面列举的异常。** 

## LineNumberTable属性 

LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量） 之间的对应关系。 

### LocalVariableTable及LocalVariableTypeTable属性 

LocalVariableTable属性用于**描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系** 

![1604719242603](E:\soft\Typora\img\1604719242603.png)

**start_pc和length属性**分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖
的长度， **两者结合起来就是这个局部变量在字节码之中的作用域范围。**

**name_index和descriptor_index**都是指向常量池中CONSTANT_Utf8_info型常量的索引， 分别代表了
**局部变量的名称以及这个局部变量的描述符。**

**index是这个局部变量在栈帧的局部变量表中变量槽的位置**。 当这个变量数据类型是64位类型时
（double和long） ， 它占用的变量槽为index和index+1两个。

顺便提一下， 在JDK 5引入泛型之后， LocalVariableTable属性增加了一个“姐妹属性”——
**LocalVariableTypeTable**。 这个新增的属性结构与LocalVariableTable非常相似， 仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature） 。 **对于非泛型类型来说， 描述符和特征签名能描述的信息是能吻合一致的， 但是泛型引入之后， 由于描述符中泛型的参数化类型被擦除掉[3]， 描述符就不能准确描述泛型类型了。 因此出现了LocalVariableTypeTable属性， 使用字段的特征签名来完成泛型的描述** 

## ConstantValue属性 

**ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。 只有被static关键字修饰的变量（类变量） 才可以使用这项属性。** 

### 赋值时机

#### 实例变量 

对非static类型的变量（也就是实例变量） 的赋值是在实例构造器<init>()方法中进行的 

#### 类变量 

**在类构造器<clinit>()方法中或者使用ConstantValue属性** 

- 如果**同时使用final和static来修饰一个变量**（按照习惯， 这里称“常量”更贴切） ， 并且这个变量的数据类型是基本类型或者java.lang.String的话， 就**将会生成ConstantValue属性来进行初始化**；

- **如果这个变量没有被final修饰， 或者并非基本类型及字符串， 则将会选择在<clinit>()方法中进行初始化。** 

## StackMapTable属性 

StackMapTable属性在JDK 6增加到Class文件规范之中， 它是一个相当复杂的变长属性， **位于Code属性的属性表中。 这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（TypeChecker） 使用（详见第7章字节码验证部分） ， 目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。** 

## Signature属性 

Signature属性在JDK 5增加到Class文件规范之中， 它是一个可选的定长属性， 可以出现于类、 字段表和方法表结构的属性表中。 

**Signature属性会为它记录泛型签名信息** 

**因为Java语言的泛型采用的是擦除法实现的伪泛型， 字节码（Code属性） 中所有的泛型信息编译（类型变量、 参数化类型） 在编译之后都通通被擦除掉。** 

## BootstrapMethods属性 

BootstrapMethods属性在JDK 7时增加到Class文件规范之中， 它是一个复杂的变长属性， **位于类文件的属性表中。 这个属性用于保存invokedynamic指令引用的引导方法限定符。** 

## MethodParameters属性 

MethodParameters是在JDK 8时新加入到Class文件格式中的， 它是一个用在方法表中的变长属性。
**MethodParameters的作用是记录方法的各个形参名称和信息。**

最初， 基于存储空间的考虑， Class文件默认是不储存方法参数名称的， 因为给参数起什么名字对计算机执行程序来说是没有任何区别的， 所以只要在源码中妥当命名就可以了。 随着Java的流行， 这点确实为程序的传播和次复用带来了诸多不便， 由于Class文件中没有参数的名称， 如果只有单独的程序包而不附加上JavaDoc的话， IDE中编辑使用包里面的方法时是无法获得方法调用的智能提示的， 这就阻碍了JAR包的传播。 后来， “-g： var”就成为了Javac以及许多IDE编译Class时采用的默认值， 这样会将方法参数的名称生成到LocalVariableTable属性之中。 不过此时问题仍然没有全部解决，LocalVariableTable属性是Code属性的子属性——没有方法体存在， 自就不会有局部变量表， 但是对于其他情况， 譬如抽象方法和接口方法， 是理所当然地可以不存在方法体的， 对于方法签名来说， 还是没有找到一个统一完整的保留方法参数名称的地方。 所以JDK 8中新增的这个属性， **使得编译器可以（编译时加上-parameters参数） 将方法名称也写进Class文件中， 而且MethodParameters是方法表的属性， 与Code属性平级的， 可以运行时通过反射API获取。**  



