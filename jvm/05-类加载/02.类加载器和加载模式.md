# 类加载器 

Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节
流”这个动作放到Java虚拟机外部去实现， 以便让应用程序自己决定如何去获取所需的类。 实现这个动
作的代码被称为“类加载器”（Class Loader） 。 

# 类与类加载器 

类加载器虽然只用于实现类的加载动作， 但它在Java程序中起到的作用却远超类加载阶段。 对于
**任意一个类， 都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性， 每一个类加载器， 都拥有一个独立的类名称空间。** 这句话可以表达得更通俗一些： **比较两个类是否“相**
**等”， 只有在这两个类是由同一个类加载器加载的前提下才有意义**， 否则， 即使这两个类来源于同一个
Class文件， 被同一个Java虚拟机加载， 只要加载它们的类加载器不同， 那这两个类就必定不相等。 

 **这里所指的“相等”， 包括代表类的Class对象的equals()方法、 isAssignableFrom()方法、 isInstance()**
**方法的返回结果**， 也包括了使用instanceof关键字做对象所属关系判定等各种情况。 如果没有注意到类
加载器的影响， 在某些情况下可能会产生具有迷惑性的结果， 代码清单7-8中演示了不同的类加载器对
instanceof关键字运算的结果的影响 

## 双亲委派模型 

本节内容将针对JDK 8及之前版本的Java来介绍什么是三层类加载器， 以及什么是双亲委派模型。
对于这个时期的Java应用， 绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载。 

**启动类加载器**（Bootstrap Class Loader） ： 前面已经介绍过， **这个类加载器负责加载存放在**
**<JAVA_HOME>\lib目录， 或者被-Xbootclasspath参数所指定的路径中存放的**， 而且是Java虚拟机能够
识别的（按照文件名识别， 如rt.jar、 tools.jar， 名字不符合的类库即使放在lib目录中也不会被加载） 类
库加载到虚拟机的内存中。 **启动类加载器无法被Java程序直接引用**， 用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理， 那直接使用null代替即可。

**扩展类加载器**（Extension Class Loader） ： **这个类加载器是在类sun.misc.Launcher$ExtClassLoader**
**中以Java代码的形式实现的**。 **它负责加载<JAVA_HOME>\lib\ext目录中， 或者被java.ext.dirs系统变量所**
**指定的路径中所有的类库**。 根据“扩展类加载器”这个名称， 就可以推断出这是一种Java系统类库的扩
展机制， JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能， 在JDK
9之后， 这种扩展机制被模块化带来的天然的扩展能力所取代。 由于扩展类加载器是由Java代码实现
的， **开发者可以直接在程序中使用扩展类加载器来加载Class文件** 

**应用程序类加载器**（Application Class Loader） ： **这个类加载器由sun.misc.Launcher$AppClassLoader来实现**。 **由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值， 所以有些场合中也称它为“系统类加载器”。 它负责加载用户类路径（ClassPath） 上所有的类库， 开发者同样可以直接在代码中使用这个类加载器。** 如果应用程序中没有自定义过自己的类加载器， 一般情况下这个就是程序中默认的类加载器。 

![1604739849709](E:\soft\Typora\img\1604739849709.png)

**图7-2中展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents Delegation**
**Model） ”。** 双亲委派模型要求除了顶层的启动类加载器外， 其余的类加载器都应有自己的父类加载
器。  

### 双亲委派模型的工作过程 

**如果一个类加载器收到了类加载的请求， 它首先不会自己去尝试加载这个类， 而是把这个请求委派给父类加载器去完成， 每一个层次的类加载器都是如此， 因此所有的加载请求最终都应该传送到最顶层的启动类加载器中， 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类） 时， 子加载器才会尝试自己去完成加载。** 

优点：不重不漏，安全

不重：因为每个类都只会被一个类加载器加载一次。

不漏：每个类都会被加载

安全：**Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系** ，例如类java.lang.Object， 它存放在rt.jar之中， 无论哪一个类加载器要加载这个类， 最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此Object类在程序的各种类加载器环境中都能够保证是同一个类。 反之， 如果没有使用双亲委派模型， 都由各个类加载器自行去加载的话， 如果用户自己也编写了一个名为java.lang.Object的类， 并放在程序的ClassPath中， 那系统中就会出现多个不同的Object类， Java类型体系中最基础的行为也就无从保证， 应用程序将会变得一片混乱。  

### 双亲委派模型的实现 

双亲委派模型对于保证Java程序的稳定运作极为重要， 但它的实现却异常简单， 用以实现双亲委
派的代码只有短短十余行， 全部集中在java.lang.ClassLoader的loadClass()方法之中， 如代码清单7-10所
示。 

```java
protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException
{
// 首先， 检查请求的类是否已经被加载过了
Class c = findLoadedClass(name);
if (c == null) {
try {
if (parent != null) {
c = parent.loadClass(name, false);
} else {
c = findBootstrapClassOrNull(name);
}}
catch (ClassNotFoundException e) {
// 如果父类加载器抛出ClassNotFoundException
// 说明父类加载器无法完成加载请求
}i
f (c == null) {
// 在父类加载器无法加载时
// 再调用本身的findClass方法来进行类加载
c = findClass(name);
}
}i
f (resolve) {
resolveClass(c);
}
```

这段代码的逻辑清晰易懂： **先检查请求加载的类型是否已经被加载过， 若没有则调用父加载器的loadClass()方法， 若父加载器为空则默认使用启动类加载器作为父加载器。 假如父类加载器加载失败，抛出ClassNotFoundException异常的话， 才调用自己的findClass()方法尝试进行加载。** 

## 破坏双亲委派模型

双亲委派模型的**第一次“被破坏”**其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远
古”时代。 由于双亲委派模型在JDK 1.2之后才被引入， 但是类加载器的概念和抽象类
java.lang.ClassLoader则在Java的第一个版本中就已经存在， 面对已经存在的用户自定义类加载器的代
码， Java设计者们引入双亲委派模型时不得不做出一些妥协， 为了兼容这些已有代码， 无法再以技术
手段避免loadClass()被子类覆盖的可能性， 只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的
protected方法findClass()， 并引导用户编写的类加载逻辑时尽可能去重写这个方法， 而不是在
loadClass()中编写代码。 上节我们已经分析过loadClass()方法， 双亲委派的具体逻辑就实现在这里面，
按照loadClass()方法的逻辑， 如果父类加载失败， 会自动调用自己的findClass()方法来完成加载， 这样
既不影响用户按照自己的意愿去加载类， 又可以保证新写出来的类加载器是符合双亲委派规则的 

双亲委派模型的**第二次“被破坏”**是由这个模型自身的缺陷导致的， 双亲委派很好地解决了各个类
加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载） ， 基础类型之所以被
称为“基础”， 是因为它们总是作为被用户代码继承、 调用的API存在， **但程序设计往往没有绝对不变的完美规则， 如果有基础类型又要调用回用户的代码， 那该怎么办呢？** 

为了解决这个困境， Java的设计团队只好引入了一个不太优雅的设计： **线程上下文类加载器**
（Thread Context ClassLoader） 。 这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方
法进行设置， 如果创建线程时还未设置， 它将会从父线程中继承一个， 如果在应用程序的全局范围内
都没有设置过的话， 那这个类加载器默认就是应用程序类加载器。 **Java中涉及SPI的加载基本上都采用这种方式来完成， 例如JNDI、JDBC、 JCE、 JAXB和JBI等。**  

双亲委派模型的**第三次“被破坏”**是由于用户对程序动态性的追求而导致的， 这里所说的“动态
性”指的是一些非常“热”门的名词： **代码热替换（Hot Swap） 、 模块热部署（Hot Deployment） 等** 

# Java模块化系统 

