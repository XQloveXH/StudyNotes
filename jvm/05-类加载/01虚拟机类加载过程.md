# 概述

**Java虚拟机把描述类的数据从Class文件加载到内存， 并对数据进行校验、 转换解析和初始化， 最终形成可以被虚拟机直接使用的Java类型， 这个过程被称作虚拟机的类加载机制。**  

**在Java语言里面， 类型的加载、 连接和初始化过程都是在程序运行期间完成的**， 这种策略让Java语言进行提前编译会面临额外的困难， 也会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性， Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。  

# 类加载的时机 

一个类型从被加载到虚拟机内存中开始， 到卸载出内存为止， 它的整个生命周期将会经历加载
（Loading） 、 验证（Verification） 、 准备（Preparation） 、 解析（Resolution） 、 初始化
（Initialization） 、 使用（Using） 和卸载（Unloading） 七个阶段， 其中验证、 准备、 解析三个部分统称
为连接（Linking） 。  

![1604728281244](E:\soft\Typora\img\1604728281244.png)

图7-1中， **加载、 验证、 准备、 初始化和卸载这五个阶段的顺序是确定的**， 类型的加载过程必须按
照这种顺序按部就班地开始， 而**解析阶段则不一定**： 它在某些情况下可以在初始化阶段之后再开始，
这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定） 。  

## 类进行初始化的六种情况（主动引用）

1） **遇到new、 getstatic、 putstatic或invokestatic这四条字节码指令时**， 如果类型没有进行过初始
化， 则需要先触发其初始化阶段。 能够生成这四条指令的典型Java代码场景有：

- 使用new关键字实例化对象的时候。
- 读取或设置一个类型的静态字段（被final修饰、 已在编译期把结果放入常量池的静态字段除外）
  的时候。
- 调用一个类型的静态方法的时候。

2） **使用java.lang.reflect包的方法对类型进行反射调用的时候**， 如果类型没有进行过初始化， 则需
要先触发其初始化。
3） **当初始化类的时候， 如果发现其父类还没有进行过初始化**， 则需要先触发其父类的初始化。
4） **当虚拟机启动时， 用户需要指定一个要执行的主类（ 包含main()方法的那个类） ， 虚拟机会先**
**初始化这个主类。**
5） 当使用JDK 7新加入的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例最后的解
析结果为REF_getStatic、 REF_putStatic、 REF_invokeStatic、 REF_newInvokeSpecial四种类型的方法句
柄， 并且这个方法句柄对应的类没有进行过初始化， 则需要先触发其初始化。
6） **当一个接口中定义了JDK 8新加入的默认方法（ 被default关键字修饰的接口方法） 时， 如果有**
**这个接口的实现类发生了初始化， 那该接口要在其之前被初始化。** 

## 被动引用

对于这六种会触发类型进行初始化的场景， 《Java虚拟机规范》 中使用了一个非常强烈的限定语
——**“有且只有”， 这六种场景中的行为称为对一个类型进行主动引用。** **除此之外， 所有引用类型的方式都不会触发初始化， 称为被动引用。**  

### 通过子类引用父类的静态字段， 不会导致子类初始化 

![1604728784299](E:\soft\Typora\img\1604728784299.png)

### 通过数组定义来引用类， 不会触发此类的初始化 

![1604728818058](E:\soft\Typora\img\1604728818058.png)

这段代码复用了代码清单7-1中的SuperClass， 运行之后发现没有输出“SuperClass
init！ ”， **说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。 但是这段代码里面触发了**
**另一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段， 对于用户代码来说， 这并不是**
**一个合法的类型名称， 它是一个由虚拟机自动生成的、 直接继承于java.lang.Object的子类， 创建动作由**
**字节码指令newarray触发。**
**这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组， 数组中应有的属性**
**和方法（**用户可直接使用的只有被修饰为public的length属性和clone()方法） 都实现在这个类里。 Java语
言中对数组的访问要比C/C++相对安全， 很大程度上就是因为这个类包装了数组元素的访问[1]， 而
C/C++中则是直接翻译为对数组指针的移动。 在Java语言里， 当检查到发生数组越界时会抛出
java.lang.ArrayIndexOutOfBoundsException异常， 避免了直接造成非法内存访问。 

### 定义常量的类的初始化 

```java

package org.fenixsoft.classloading;
/**
* 被动使用类字段演示三：
* 常量在编译阶段会存入调用类的常量池中， 本质上没有直接引用到定义常量的类， 因此不会触发定义常量的
类的初始化
**/
public class ConstClass {
static {
System.out.println("ConstClass init!");
} p
ublic static final String HELLOWORLD = "hello world";
} /
**
* 非主动使用类字段演示
**/
public class NotInitialization {
public static void main(String[] args) {
System.out.println(ConstClass.HELLOWORLD);
}
}
```



上述代码运行之后， 也没有输出“ConstClass init！ ”， 这是因为虽然在Java源码中确实引用了ConstClass类的常量HELLOWORLD， 但其实**在编译阶段通过常量传播优化**， 已经将此常量的值“helloworld”直接存储在NotInitialization类的常量池中， 以后**NotInitialization对常量ConstClass.HELLOWORLD的引用， 实际都被转化为NotInitialization类对自身常量池的引用了**。 也就是说， 实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口， 这两个类在编译成Class文件后就已不存在任何联系了 

## 类与接口初始化的区别

接口的加载过程与类加载过程稍有不同， 针对接口需要做一些特殊说明： 接口也有初始化过程，
这点与类是一致的， 上面的代码都是用静态语句块“static{}”来输出初始化信息的， 而接口中不能使
用“static{}”语句块， 但编译器仍然会为接口生成“<clinit>()”类构造器[2]， 用于初始化接口中所定义的
成员变量。** **接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种：**
**当一个类在初始化时， 要求其父类全部都已经初始化过了， 但是一个接口在初始化时， 并不要求其父**
**接口全部都完成了初始化， 只有在真正使用到父接口的时候（如引用接口中定义的常量） 才会初始**
化。** 

# 类加载的过程

## 加载 

“加载”（Loading） 阶段是**整个“类加载”（Class Loading） 过程中的一个阶段** ，Java虚拟机需要完成以下三件事情 ：

1） **通过一个类的全限定名来获取定义此类的二进制字节流。**
2） **将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。**
3） **在内存中生成一个代表这个类的java.lang.Class对象， 作为方法区这个类的各种数据的访问入口。** 

### 二进制字节流的加载方法

- 从ZIP压缩包中读取， 这很常见， 最终成为日后JAR、 EAR、 WAR格式的基础。
- 从网络中获取， 这种场景最典型的应用就是Web Applet。
- 运行时计算生成， 这种场景使用得最多的就是动态代理技术， 在java.lang.reflect.Proxy中， 就是用
  了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。
- 由其他文件生成， 典型场景是JSP应用， 由JSP文件生成对应的Class文件。
- 从数据库中读取， 这种场景相对少见些， 例如有些中间件服务器（如SAP Netweaver） 可以选择
  把程序安装到数据库中来完成程序代码在集群间的分发。
- 可以从加密文件中获取， 这是典型的防Class文件被反编译的保护措施， 通过加载时解密Class文
  件来保障程序运行逻辑不被窥探。
- …… 

### 数组类的加载

对于数组类而言， 情况就有所不同， **数组类本身不通过类加载器创建， 它是由Java虚拟机直接在内存中动态构造出来的**。 但数组类与类加载器仍然有很密切的关系， **因为数组类的元素类型（ElementType， 指的是数组去掉所有维度的类型） 最终还是要靠类加载器来完成加载，** 一个数组类（ 下面简称为C） 创建过程遵循以下规则： 

- 如果数组的组件类型（ Component Type， 指的是数组去掉一个维度的类型， 注意和前面的元素类型区分开来） 是引用类型， 那就递归采用本节中定义的加载过程去加载这个组件类型， 数组C将被标识在加载该组件类型的类加载器的类名称空间上
- 如果数组的组件类型不是引用类型（ 例如int[]数组的组件类型为int） ， Java虚拟机将会把数组C
  标记为与引导类加载器关联。
- 数组类的可访问性与它的组件类型的可访问性一致， 如果组件类型不是引用类型， 它的数组类的
  可访问性将默认为public， 可被所有的类和接口访问到。 

**加载阶段与连接阶段的部分动作（ 如一部分字节码文件格式验证动作） 是交叉进行的**， 加载阶段
尚未完成， 连接阶段可能已经开始， 但这些夹在加载阶段之中进行的动作， 仍然属于连接阶段的一部
分， 这两个阶段的开始时间仍然保持着固定的先后顺序。 

## 验证 

验证是连接阶段的第一步， 这一阶段的目的是**确保Class文件的字节流中包含的信息符合《Java虚拟机规范》 的全部约束要求， 保证这些信息被当作代码运行后不会危害虚拟机自身的安全。** 

Java语言本身是相对安全的编程语言（起码对于C/C++来说是相对安全的） ， 使用纯粹的Java代码
无法做到诸如访问数组边界以外的数据、 将一个对象转型为它并未实现的类型、 跳转到不存在的代码
行之类的事情， 如果尝试这样去做了， 编译器会毫不留情地抛出异常、 拒绝编译。 但前面也曾说过，
Class文件并不一定只能由Java源码编译而来， 它可以使用包括靠键盘0和1直接在二进制编辑器中敲出
Class文件在内的任何途径产生。 上述Java代码无法做到的事情在字节码层面上都是可以实现的， 至少
语义上是可以表达出来的。** **Java虚拟机如果不检查输入的字节流， 对其完全信任的话， 很可能会因为**
**载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃， 所以验证字节码是Java虚拟**
**机保护自身的一项必要措施**

验证阶段大致上会完成下面四个阶段的检验动作： **文件格式验证、 元数据验证、 字节码验证和符号引用验证。**

### 文件格式验证 

**第一阶段要验证字节流是否符合Class文件格式的规范， 并且能被当前版本的虚拟机处理**。 这一阶
段可能包括下面这些验证点：

是否以魔数0xCAFEBABE开头。

- 主、 次版本号是否在当前Java虚拟机接受范围之内。
- 常量池的常量中是否有不被支持的常量类型（检查常量tag标志） 。
- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
- CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。
- Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。
- ……   

**该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内， 格式上符合描述一个Java类型信息的要求。 这阶段的验证是基于二进制字节流进行的， 只有通过了这个阶段的验证之后， 这段字节流才被允许进入Java虚拟机内存的方法区中进行存储， 所以后面的三个验证阶段全部是基于方法区的存储结构上进行的， 不会再直接读取、 操作字节流了。** 

### 元数据验证 

**第二阶段是对字节码描述的信息进行语义分析， 以保证其描述的信息符合《Java语言规范》 的要求**， 这个阶段可能包括的验证点如下： 

这个类是否有父类（除了java.lang.Object之外， 所有的类都应当有父类） 。

- 这个类的父类是否继承了不允许被继承的类（被final修饰的类） 。
- 如果这个类不是抽象类， 是否实现了其父类或接口之中要求实现的所有方法。
- 类中的字段、 方法是否与父类产生矛盾（例如覆盖了父类的final字段， 或者出现不符合规则的方
  法重载， 例如方法参数都一致， 但返回值类型却不同等） 。
- ……

**第二阶段的主要目的是对类的元数据信息进行语义校验， 保证不存在与《Java语言规范》 定义相**
**悖的元数据信息。**

### 字节码验证 

第三阶段是整个验证过程中最复杂的一个阶段， **主要目的是通过数据流分析和控制流分析， 确定**
**程序语义是合法的、 符合逻辑的。** **在第二阶段对元数据信息中的数据类型校验完毕以后， 这阶段就要**
**对类的方法体（Class文件中的Code属性） 进行校验分析**， 保证被校验类的方法在运行时不会做出危害
虚拟机安全的行为， 例如：

- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作， 例如不会出现类似于“在操作
  栈放置了一个int类型的数据， 使用时却按long类型来加载入本地变量表中”这样的情况。
- 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。
- 保证方法体中的类型转换总是有效的， 例如可以把一个子类对象赋值给父类数据类型， 这是安全
  的， 但是把父类对象赋值给子类数据类型， 甚至把对象赋值给与它毫无继承关系、 完全不相干的一个
  数据类型， 则是危险和不合法的。
- …… 

#### StackMapTable 

**由于数据流分析和控制流分析的高度复杂性**， Java虚拟机的设计团队为了避免过多的执行时间消
耗在字节码验证阶段中， **在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化， 把尽可能**
**多的校验辅助措施挪到Javac编译器里进行**。

 具体做法是给方法体Code属性的属性表中新增加了一项名为“**StackMapTable**”的新属性， **这项属性描述了方法体所有的基本块（Basic Block， 指按照控制流拆分的代码块） 开始时本地变量表和操作栈应有的状态， 在字节码验证期间， Java虚拟机就不需要根据程序推导这些状态的合法性， 只需要检查StackMapTable属性中的记录是否合法即可。** 这样就将字节码验证的类型推导转变为类型检查， 从而节省了大量校验时间。 理论上StackMapTable属性也存在错误或被篡改的可能， 所以是否有可能在恶意篡改了Code属性的同时， 也生成相应的StackMapTable属性来骗过虚拟机的类型校验， 则是虚拟机设计者们需要仔细思考的问题。 

### 符号引用验证 

最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用[3]的时候， 这个转化动作将在
连接的第三阶段——**解析阶段中发生**。 **符号引用验证可以看作是对类自身以外（常量池中的各种符号**
**引用） 的各类信息进行匹配性校验，** 通俗来说就是， 该类是否缺少或者被禁止访问它依赖的某些外部
类、 方法、 字段等资源。 本阶段通常需要校验下列内容： 

- **符号引用中通过字符串描述的全限定名是否能找到对应的类。**
- **在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。**
- **符号引用中的类、 字段、 方法的可访问性（private、 protected、 public、 <package>） 是否可被类访问。**
- …… 

**符号引用验证的主要目的是确保解析行为能正常执行**， 如果无法通过符号引用验证， Java虚拟机将会抛出一个java.lang.IncompatibleClassChangeError的子类异常， 典型的如：**java.lang.IllegalAccessError、 java.lang.NoSuchFieldError、 java.lang.NoSuchMethodError等。** 

## 准备 

**准备阶段是正式为类中定义的变量（即静态变量， 被static修饰的变量） 分配内存并设置类变量初始值的阶段， 从概念上讲， 这些变量所使用的内存都应当在方法区中进行分配， 但必须注意到方法区本身是一个逻辑上的区域， 在JDK 7及之前， HotSpot使用永久代来实现方法区时， 实现是完全符合这种逻辑概念的； 而在JDK 8及之后， 类变量则会随着Class对象一起存放在Java堆中， 这时候“类变量在方法区”就完全是一种对逻辑概念的表述了** 

### 通常情况是赋零值

```java
public static int value = 123;
```

**那变量value在准备阶段过后的初始值为0而不是123，** 因为这时尚未开始执行任何Java方法， 而把
value赋值为123的putstatic指令是程序被编译后， 存放于类构造器<clinit>()方法之中，** **所以把value赋值为123的动作要到类的初始化阶段才会被执行。**  

![1604736767208](E:\soft\Typora\img\1604736767208.png)

### 特殊情况

```java
public static final int value = 123;
```

**如果类字段的字段属性表中存在ConstantValue属性， 那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值，**  编译时Javac将会为value生成ConstantValue属性， 在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。 

## 解析 

**解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程** 

### 符号引用

符号引用（Symbolic References） ： **符号引用以一组符号来描述所引用的目标， 符号可以是任何**
**形式的字面量， 只要使用时能无歧义地定位到目标即可**。 符号引用与虚拟机实现的内存布局无关， 引
用的目标并不一定是已经加载到虚拟机内存当中的内容。 各种虚拟机实现的内存布局可以各不相同，
但是它们能接受的符号引用必须都是一致的， 因为符号引用的字面量形式明确定义在《Java虚拟机规
范》 的Class文件格式中 

### 直接引用

直接引用（Direct References） ： **直接引用是可以直接指向目标的指针、 相对偏移量或者是一个能**
**间接定位到目标的句柄。** 直接引用是和虚拟机实现的内存布局直接相关的， 同一个符号引用在不同虚
拟机实例上翻译出来的直接引用一般不会相同。 **如果有了直接引用， 那引用的目标必定已经在虚拟机**
**的内存中存在** 

### 触发解析的字节码指令

要求了在执行ane-warray、checkcast、 getfield、 getstatic、 instanceof、 invokedynamic、 invokeinterface、 invoke-special、invokestatic、 invokevirtual、 ldc、 ldc_w、 ldc2_w、 multianewarray、 new、 putfield和putstatic**这17个用于操作符号引用的字节码指令之前， 先对它们所使用的符号引用进行解析**。 所以虚拟机实现可以根据需要来自行判断， 到底是在类被加载器加载时就对常量池中的符号引用进行解析， 还是等到一个符号引用将要被使用前才去解析它。 

### invokedynamic指令 

当碰到某个前面已经由invokedynamic指令触发过解析的符号引用时， 并不意味着这个解析结果对于其他invokedynamic指令也同样生效。 因为invokedynamic指令的目的本来就是用于动态语言支持[1]， 它对应的引用称为“动态调用点限定符（Dynamically-Computed Call Site Specifier） ”， **这里“动态”的含义是指必须等到程序实际运行到这条指令时， 解析动作才能进行。** 

### 类或接口的解析 

假设当前代码所处的**类为D**， 如果要把一个从未解析过的**符号引用N**解析为**一个类或接口C的直接**
**引用**， 那虚拟机完成整个解析的过程需要包括以下3个步骤： 

1） 如果C不是一个数组类型， 那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个
类C。 在加载过程中， 由于元数据验证、 字节码验证的需要， 又可能触发其他相关类的加载动作， 例
如加载这个类的父类或实现的接口。 一旦这个加载过程出现了任何异常， 解析过程就将宣告失败。
2） 如果C是一个数组类型， 并且数组的元素类型为对象， 也就是N的描述符会是类
似“[Ljava/lang/Integer”的形式， 那将会按照第一点的规则加载数组元素类型。 如果N的描述符如前面所
假设的形式， 需要加载的元素类型就是“java.lang.Integer”， 接着由虚拟机生成一个代表该数组维度和元
素的数组对象。
3） 如果上面两步没有出现任何异常， 那么C在虚拟机中实际上已经成为一个有效的类或接口了，
但在解析完成前还要进行符号引用验证， 确认D是否具备对C的访问权限。 如果发现不具备访问权限，
将抛出java.lang.IllegalAccessError异常 

### 字段解析 

要解析一个未被解析过的字段符号引用， 首先将会对字段表内class_index[3]项中索引的
CONSTANT_Class_info符号引用进行解析， **也就是字段所属的类或接口的符号引用**。 如果在解析这个
类或接口符号引用的过程中出现了任何异常， 都会导致字段符号引用解析的失败。 如果解析成功完
成， 那把这个字段所属的类或接口用C表示， 《Java虚拟机规范》 要求按照如下步骤对C进行后续字段
的搜索： 

1） 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段， 则返回这个字段的直接引
用， 查找结束。
2） 否则， 如果在**C中实现了接口**， 将会按照**继承关系从下往上递归搜索各个接口和它的父接口**，
如果接口中包含了简单名称和字段描述符都与目标相匹配的字段， 则返回这个字段的直接引用， 查找
结束。
3） 否则， 如果**C不是java.lang.Object的话**， 将会**按照继承关系从下往上递归搜索其父类**， 如果在父
类中包含了简单名称和字段描述符都与目标相匹配的字段， 则返回这个字段的直接引用， 查找结束。
4） 否则， 查找失败， 抛出java.lang.NoSuchFieldError异常。
**如果查找过程成功返回了引用， 将会对这个字段进行权限验证， 如果发现不具备对字段的访问权限， 将抛出java.lang.IllegalAccessError异常** 

但在实际情况中， Javac编译器往往会采取比上述规范更加严格一些的约束， 譬如**有一个同名字段同时出现在某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现， 按照解析规则仍是可以确定唯一的访问字段， 但Javac编译器就可能直接拒绝其编译为Class文件。**  

### 方法解析 

方法解析的第一个步骤与字段解析一样， 也是需要先解析出方法表的class_index[4]项中索引的方
法所属的类或接口的符号引用， 如果解析成功， 那么我们依然用C表示这个类， 接下来虚拟机将会按
照如下步骤进行后续的方法搜索： 

1） 由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的， **如果在类的**
**方法表中发现class_index中索引的C是个接口的话， 那就直接抛出java.lang.IncompatibleClassChangeError**
**异常。**
2） 如果通过了第一步， 在**类C中查找**是否有简单名称和描述符都与目标相匹配的方法， 如果有则
返回这个方法的直接引用， 查找结束。
3） 否则， **在类C的父类中递归查找**是否有简单名称和描述符都与目标相匹配的方法， 如果有则返
回这个方法的直接引用， 查找结束。
4） 否则， **在类C实现的接口列表及它们的父接口**之中递归查找是否有简单名称和描述符都与目标
相匹配的方法， **如果存在匹配的方法， 说明类C是一个抽象类， 这时候查找结束， 抛出**
**java.lang.AbstractMethodError异常。**
5） **否则， 宣告方法查找失败， 抛出java.lang.NoSuchMethodError。**
**最后， 如果查找过程成功返回了直接引用， 将会对这个方法进行权限验证， 如果发现不具备对此**
**方法的访问权限， 将抛出java.lang.IllegalAccessError异常。** 

### 接口方法解析 

接口方法也是需要先解析出接口方法表的class_index[5]项中索引的方法所属的类或接口的符号引
用， 如果解析成功， 依然用C表示这个接口， 接下来虚拟机将会按照如下步骤进行后续的接口方法搜
索： 

1） 与类的方法解析相反， 如果在接口方法表中发现class_index中的索引C是个类而不是接口， 那
么就直接抛出java.lang.IncompatibleClassChangeError异常。
2） 否则， **在接口C中**查找是否有简单名称和描述符都与目标相匹配的方法， 如果有则返回这个方
法的直接引用， 查找结束。
3） 否则， **在接口C的父接口中递归查找**， **直到java.lang.Object类**（接口方法的查找范围也会包括
Object类中的方法） 为止， 看是否有简单名称和描述符都与目标相匹配的方法， 如果有则返回这个方
法的直接引用， 查找结束。
4） **对于规则3， 由于Java的接口允许多重继承， 如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法， 那将会从这多个方法中返回其中一个并结束查找， 《Java虚拟机规范》 中并没有进一步规则约束应该返回哪一个接口方法。  但与之前字段查找类似地， 不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。** 

5） 否则， 宣告方法查找失败， 抛出java.lang.NoSuchMethodError异常。 

在JDK 9之前， Java接口中的所有方法都默认是public的， 也没有模块化的访问约束， 所以不存在
访问权限的问题， 接口方法的符号解析就不可能抛出java.lang.IllegalAccessError异常。 但在JDK 9中增
加了接口的静态私有方法， 也有了模块化的访问约束， 所以从JDK 9起， 接口方法的访问也完全有可
能因访问权限控制而出现java.lang.IllegalAccessError异常。 

## 初始化 

进行准备阶段时， 变量已经赋过一次系统要求的初始零值， 而在初始化阶段， 则会根据程序员通
过程序编码制定的主观计划去初始化类变量和其他资源。 我们也可以从另外一种更直接的形式来表
达： **初始化阶段就是执行类构造器<clinit>()方法的过程**。 <clinit>()并不是程序员在Java代码中直接编写
的方法， 它是Javac编译器的自动生成物， 

### clinit方法

**<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块） 中的**
**语句合并产生的， 编译器收集的顺序是由语句在源文件中出现的顺序决定的， 静态语句块中只能访问**
**到定义在静态语句块之前的变量， 定义在它之后的变量， 在前面的静态语句块可以赋值， 但是不能访**
**问**

<clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法） 不同， 它不需要显
式地调用父类构造器， ***Java虚拟机会保证在子类的<clinit>()方法执行前， 父类的<clinit>()方法已经执完毕**（**初始化的六大触发条件**）。因此在Java虚拟中第一个被执行的<clinit>()方法的类型肯定是java.lang.Object。 

由于父类的<clinit>()方法先执行， 也就意味着父类中定义的静态语句块要优先于子类的变量赋值
操作， 如代码清单7-6中， 字段B的值将会是2而不是1。 

```java
static class Parent {
public static int A = 1;
static {
A = 2;
}
} s
tatic class Sub extends Parent {
public static int B = A;
}
```

<clinit>()方法对于类或接口来说并不是必需的， 如果一个类中没有静态语句块， 也没有对变量的
赋值操作， 那么编译器可以不为这个类生成<clinit>()方法。 

接口中不能使用静态语句块， 但仍然有变量初始化的赋值操作， 因此接口与类一样都会生成
<clinit>()方法。 但接口与类不同的是， **执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时， 父接口才会被初始化**。 此外， 接口的实现类在初始化时也
一样不会执行接口的<clinit>()方法。 

#### clinit的安全

**Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步， 如果多个线程同**
**时去初始化一个类， 那么只会有其中一个线程去执行这个类的<clinit>()方法， 其他线程都需要阻塞等**
**待， 直到活动线程执行完毕<clinit>()方法。** 如果在一个类的<clinit>()方法中有耗时很长的操作， 那就
可能造成多个进程阻塞[2]， 在实际应用中这种阻塞往往是很隐蔽的。 

-