## 对象优先在Eden分配 

**大多数情况下， 对象在新生代Eden区中分配。 当Eden区没有足够空间进行分配时， 虚拟机将发起**
**一次Minor GC。**
HotSpot虚拟机提供了-XX： **+PrintGCDetails这个收集器日志参数， 告诉虚拟机在发生垃圾收集行**
**为时打印内存回收日志， 并且在进程退出的时候输出当前的内存各区域分配情况。** 在实际的问题排查
中， 收集器日志常会打印到文件后通过工具进行分析， 不过本节实验的日志并不多， 直接阅读就能看
得很清楚。 

## 大对象直接进入老年代 

大对象就是指需要大量连续内存空间的Java对象， 最典型的大对象便是那种很长的字符串， 或者
元素数量很庞大的数组， 本节例子中的byte[]数组就是典型的大对象。 大对象对虚拟机的内存分配来说
就是一个不折不扣的坏消息， 比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对
象”， 我们写程序的时候应注意避免。 在Java虚拟机中要避免大对象的原因是， 在分配空间时， 它容易
导致内存明明还有不少空间时就提前触发垃圾收集， 以获取足够的连续空间才能安置好它们， 而当复
制对象时， 大对象就意味着高额的内存复制开销。 HotSpot虚拟机提供了**-XX： PretenureSizeThreshold**
参数， 指定大于该设置值的对象直接在老年代分配， 这样做的目的就是避免在Eden区及两个Survivor区
之间来回复制， 产生大量的内存复制操作。 

## 长期存活的对象将进入老年代 

HotSpot虚拟机中多数收集器都采用了分代收集来管理堆内存， 那内存回收时就必须能决策哪些存
活对象应当放在新生代， 哪些存活对象放在老年代中。 为做到这点， 虚拟机给每个对象定义了一个对
象年龄（Age） 计数器， 存储在对象头中（详见第2章） 。 对象通常在Eden区里诞生， 如果经过第一次
Minor GC后仍然存活， 并且能被Survivor容纳的话， 该对象会被移动到Survivor空间中， 并且将其对象
年龄设为1岁。 对象在Survivor区中每熬过一次Minor GC， 年龄就增加1岁， 当它的年龄增加到一定程
度（默认为15） ， 就会被晋升到老年代中。 对象晋升老年代的年龄阈值， 可以通过参数-XX：
MaxTenuringThreshold设置。 

## 动态对象年龄判定 

为了能更好地适应不同程序的内存状况， HotSpot虚拟机并不是永远要求对象的年龄必须达到-
XX： MaxTenuringThreshold才能晋升老年代， 如果在Survivor空间中相同年龄所有对象大小的总和大于
Survivor空间的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代， 无须等到-XX：
MaxTenuringThreshold中要求的年龄 

## 空间分配担保 

在发生Minor GC之前， 虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总
空间， 如果这个条件成立， 那这一次Minor GC可以确保是安全的。 如果不成立， 则虚拟机会先查看-
XX： HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure） ； 如果允
许， 那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大
于， 将尝试进行一次Minor GC， 尽管这次Minor GC是有风险的； 如果小于， 或者-XX：
HandlePromotionFailure设置不允许冒险， 那这时就要改为进行一次Full GC。 

解释一下“冒险”是冒了什么风险： 前面提到过， 新生代使用复制收集算法， 但为了内存利用率，
只使用其中一个Survivor空间来作为轮换备份， 因此当出现大量对象在Minor GC后仍然存活的情况
——最极端的情况就是内存回收后新生代中所有对象都存活， **需要老年代进行分配担保， 把Survivor无**
**法容纳的对象直接送入老年代，** 这与生活中贷款担保类似。 老年代要进行这样的担保， 前提是老年代
本身还有容纳这些对象的剩余空间， 但一共有多少对象会在这次回收中活下来在实际完成内存回收之
前是无法明确知道的， 所以只能取之前每一次回收晋升到老年代对象容量的平均大小作为经验值， 与
老年代的剩余空间进行比较， 决定是否进行Full GC来让老年代腾出更多空间。 