## 垃圾回收算法

从如何判定对象消亡的角度出发， 垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference
Counting GC） 和“追踪式垃圾收集”（Tracing GC） 两大类， 这两类也常被称作“直接垃圾收集”和“间接
垃圾收集”。 由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及， 所以我们暂不
把它作为正文主要内容来讲解， **本节介绍的所有算法均属于追踪式垃圾收集的范畴。**  

## 分代收集理论

当前商业虚拟机的垃圾收集器， 大多数都遵循了“分代收集”（Generational Collection） [1]的理论进
行设计， **分代收集名为理论， 实质是一套符合大多数程序运行实际情况的经验法则， 它建立在两个分**
**代假说之上：**
**1） 弱分代假说（Weak Generational Hypothesis） ： 绝大多数对象都是朝生夕灭的。**
**2） 强分代假说（Strong Generational Hypothesis） ： 熬过越多次垃圾收集过程的对象就越难以消亡。**

假如要现在进行一次只局限于新生代区域内的收集（Minor GC） ， 但新生代中的对象是完全有可
能被老年代所引用的， 为了找出该区域中的存活对象， 不得不在固定的GC Roots之外， 再额外遍历整
个老年代中所有对象来确保可达性分析结果的正确性， 反过来也是一样[3]。 遍历整个老年代所有对象
的方案虽然理论上可行， 但无疑会为内存回收带来很大的性能负担。 为了解决这个问题， 就需要对分
代收集理论添加第三条经验法则：

**3） 跨代引用假说（ Intergenerational Reference Hypothesis） ： 跨代引用相对于同代引用来说仅占极**
**少数。**
这其实是可根据前两条假说逻辑推理得出的隐含推论： **存在互相引用关系的两个对象， 是应该倾**
**向于同时生存或者同时消亡的**。 举个例子， 如果某个新生代对象存在跨代引用， 由于老年代对象难以
消亡， 该引用会使得新生代对象在收集时同样得以存活， 进而在年龄增长之后晋升到老年代中， 这时
跨代引用也随即被消除了。

依据这条假说， 我们就不应再为了少量的跨代引用去扫描整个老年代， 也不必浪费空间专门记录
每一个对象是否存在及存在哪些跨代引用， 只需在新生代上建立一个全局的数据结构（ 该结构被称
为“记忆集”， Remembered Set） ， 这个结构把老年代划分成若干小块， 标识出老年代的哪一块内存会
存在跨代引用。 此后当发生Minor GC时， 只有包含了跨代引用的小块内存里的对象才会被加入到GC
Roots进行扫描。 虽然这种方法需要在对象改变引用关系（ 如将自己或者某个属性赋值） 时维护记录数
据的正确性， 会增加一些运行时的开销， 但比起收集时扫描整个老年代来说仍然是划算的。
注意 刚才我们已经提到了“Minor GC”， 后续文中还会出现其他针对不同分代的类似名词，

为避免读者产生混淆， 在这里统一定义：

- 部分收集（ Partial GC） ： 指目标不是完整收集整个Java堆的垃圾收集， 其中又分为：

- 新生代收集（ Minor GC/Young GC） ： 指目标只是新生代的垃圾收集。

- 老年代收集（ Major GC/Old GC） ： 指目标只是老年代的垃圾收集。 目前只有CMS收集器会有单独收集老年代的行为。 另外请注意“Major GC”这个说法现在有点混淆， 在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。

- 混合收集（ Mixed GC） ： 指目标是收集整个新生代以及部分老年代的垃圾收集。 目前只有G1收集器会有这种行为。

- 整堆收集（ Full GC） ： 收集整个Java堆和方法区的垃圾收集。


  **通常能单独发生收集行为的只是新生代， 所以这里“反过来”的情况只是理论上允许， 实际上除了**
  **CMS收集器， 其他都不存在只针对老年代的收集。**  



## 标记-清除算法

### 算法思想

算法分为“标记”和“清除”两个阶段： 首先标记出所有需要回收的对象， 在标记完成后， 统一回收掉所有被标记的对象， 也可以反过来， 标记存活的对象， 统一回收所有未被标记的对象。  

### 缺点

- **执行效率不稳定**。如果Java堆中包含大量对象， 而且其中大部分是需要被回收的， 这时必须进行大量标记和清除的动作， 导致**标记和清除两个过程的执行效率都随对象数量增长而降低** 
- **内存空间的碎片化问题 **。标记、 清除之后会产生大量不连续的内存碎片， 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 

![1603259613263](E:\soft\Typora\img\1603259613263.png)



## 标记-复制算法 

### 算法思想

将可用内存按容量划分为大小相等的两块， 每次只使用其中的一块。 当这一块的内存用完了， 就将还存活着
的对象复制到另外一块上面， 然后再把已使用过的内存空间一次清理掉。(**一般用于新生代垃圾回收**)

###  优点

执行效率高，耗时间的操作是复制对象。对于新生代来说，每次都只有少部分对象能够存活，所以新生代的回收一般使用标记复制算法

### 缺点

这种复制回收算法的代价是将可用内存缩小为了原来的一半， **空间浪费未免太多**了一点。 

![1603260688479](E:\soft\Typora\img\1603260688479.png)

**HotSpot虚拟机默认Eden和Survivor的大小比例是8∶ 1**， 也即每次新生代中可用内存空间为整个新
生代容量的90%（Eden的80%加上一个Survivor的10%） ， 只有一个Survivor空间， **即10%的新生代是会被“浪费”的**。  



## 标记-整理算法 

### 算法思想

其中的标记过程仍然与“标记-清除”算法一样， 但后续步骤不是直接对可回收对象进行清理， 而是让所有存活的对象都向内存空间一端移动， 然后直接清理掉边界以外的内存 

![1603261184733](E:\soft\Typora\img\1603261184733.png)



### 是否移动

**标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法， 而后者是移动式的** 

**如果移动存活对象， 尤其是在老年代这种每次回收都有大量对象存活区域， 移动存活对象并更新**
**所有引用这些对象的地方将会是一种极为负重的操作**， 而且这种对象移动操作必须全程暂停用户应用
程序才能进行[1]， 这就更加让使用者不得不小心翼翼地权衡其弊端了， 像这样的停顿被最初的虚拟机
设计者形象地描述为“**Stop The World**”[2]。 

但如果跟标记-清除算法那样完全**不考虑移动和整理存活对象的话**， 弥散于堆中的存活对象导致的
**空间碎片化问题**就只能依赖更为复杂的内存分配器和内存访问器来解决。 

**基于以上两点， 是否移动对象都存在弊端， 移动则内存回收时会更复杂， 不移动则内存分配时会**
**更复杂。** 从垃圾收集的停顿时间来看， 不移动对象停顿时间会更短， 甚至可以不需要停顿， 但是从整
个程序的吞吐量来看， 移动对象会更划算。 此语境中， 吞吐量的实质是赋值器（Mutator， 可以理解为
使用垃圾收集的用户程序， 本书为便于理解， 多数地方用“用户程序”或“用户线程”代替） 与收集器的
效率总和。 即使不移动对象会使得收集器的效率提升一些， 但因内存分配和访问相比垃圾收集频率要
高得多， 这部分的耗时增加， 总吞吐量仍然是下降的。 HotSpot虚拟机里面关注吞吐量的Parallel
Scavenge收集器是基于标记-整理算法的， 而关注延迟的**CMS收集器则是基于标记-清除算法**的， 这也从
侧面印证这点。
另外， 还有一种“**和稀泥式**”解决方案可以不在内存分配和访问上增加太大额外负担， 做法是**让虚**
**拟机平时多数时间都采用标记-清除算法， 暂时容忍内存碎片的存在， 直到内存空间的碎片化程度已经**
**大到影响对象分配时， 再采用标记-整理算法收集一次， 以获得规整的内存空间。** 前面提到的基于标
记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。 





 









