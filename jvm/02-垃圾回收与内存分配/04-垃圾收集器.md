

## Serial收集器 

这个收集器是一个**单线程工作的收集器**， 但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作， 更重要的是强调在它进行垃圾收集时， **必须暂停其他所有工作线程**， 直到它收集结束。 

### 运行过程

![1603264852086](E:\soft\Typora\img\1603264852086.png)

### 优点

对于内存资源受限的环境， 它是所有收集器里额外内存消耗（Memory Footprint） [1]最小的；

 对于单核处理器或处理器核心数较少的环境来说， Serial收集器由于没有线程交互的开销， 专心做垃圾收集自然可以获得最高的单线程收集效率。 

Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择  。

## ParNew收集器 

ParNew收集器实质上是Serial收集器的多线程并行版本 

### 运行过程

![1603265059956](E:\soft\Typora\img\1603265059956.png)



### 过时

在JDK 5发布时， HotSpot推出了一款在强交互应用中几乎可称为具有划时代意义的垃圾收集器
——**CMS收集器**。 这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器， 它首次
实现了让垃圾收集线程与用户线程（基本上） 同时工作。

遗憾的是， CMS作为老年代的收集器， 却无法与JDK 1.4.0中已经存在的新生代收集器Parallel
Scavenge配合工作[1]， **所以在JDK 5中使用CMS来收集老年代的时候， 新生代只能选择ParNew或者**
**Serial收集器中的一个**。 ParNew收集器是激活CMS后（使用-XX： +UseConcMarkSweepGC选项） 的默
认新生代收集器， 也可以使用-XX： +/-UseParNewGC选项来强制指定或者禁用它。 

可以说**直到CMS的出现才巩固了ParNew的地位**， 但成也萧何败也萧何， 随着垃圾收集器技术的不
断改进， **更先进的G1收集器带着CMS继承者和替代者的光环登场**。 G1是一个面向全堆的收集器， 不
再需要其他新生代收集器的配合工作。 所以自JDK 9开始， ParNew加CMS收集器的组合就不再是官方
推荐的服务端模式下的收集器解决方案了。 官方希望它能完全被G1所取代， 甚至还取消了ParNew加
Serial Old以及Serial加CMS这两组收集器组合的支持（其实原本也很少人这样使用） ， 并直接取消了-
XX： +UseParNewGC参数， 这意味着ParNew和CMS从此只能互相搭配使用， 再也没有其他收集器能
够和它们配合了。 读者也可以理解为从此以后， ParNew合并入CMS， 成为它专门处理新生代的组成部
分。 **ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。** 

## Parallel Scavenge收集器 

Parallel Scavenge收集器也是一款新生代收集器， 它同样是基于标记-复制算法实现的收集器， 也是
能够并行收集的多线程收集器 ，***Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量** 

![1603265405058](E:\soft\Typora\img\1603265405058.png)

### 自适应的调节策略 

Parallel Scavenge收集器还有一个参数-XX： +UseAdaptiveSizePolicy值得我们关注。 这是一
个开关参数， 当这个参数被激活之后， 就**不需要人工指定新生代的大小（-Xmn） 、 Eden与Survivor区
的比例（-XX： SurvivorRatio） 、 晋升老年代对象大小（-XX： PretenureSizeThreshold）** 等细节参数
了， 虚拟机会根据当前系统的运行情况收集性能监控信息， 动态调整这些参数以提供最合适的停顿时
间或者最大的吞吐量。  

**自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。** 

## Serial Old收集器 

Serial Old是Serial收集器的老年代版本， 它同样是一个单线程收集器， 使用标记-整理算法。 

如果在服务端模式下， 它也可能有两种用途： 一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]， 另外一种就是作为CMS收集器发生失败时的后备预案， 在并发收集发生Concurrent Mode Failure时使用。 

![1603265658435](E:\soft\Typora\img\1603265658435.png)



## Parallel Old收集器 

Parallel Old是Parallel Scavenge收集器的老年代版本， 支持多线程并发收集， 基于标记-整理算法实
现。 

![1603265726285](E:\soft\Typora\img\1603265726285.png)

## CMS收集器 

**CMS（Concurrent Mark Sweep） 收集器是一种以获取最短回收停顿时间为目标的收集器。** 目前很
大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上， 这类应用通常都会较为
关注服务的响应速度， 希望系统停顿时间尽可能短， 以给用户带来良好的交互体验。 CMS收集器就非
常符合这类应用的需求。 

### 运行过程

#### 1） 初始标记（CMS initial mark）

初始标记仅仅只是标记一下GCRoots能直接关联到的对象， 速度很快 

#### 2） 并发标记（CMS concurrent mark）

 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行； 

#### 3） 重新标记（CMS remark）

重新标记阶段则是为了修正并发标记期间， 因用户程序继续运作而导致标记产生变动的那一部分对象的
标记记录 ， 这个阶段的停顿时间通常会比初始标记阶段稍长一些， 但也远比并发标记阶段的时间短； 

#### 4） 并发清除（CMS concurrent sweep） 

并发清除阶段， 清理删除掉标记阶段判断的已经死亡的对象， 由于不需要移动存活对象， 所以这个阶段也是可以与用户线程同时并发的。 

![1603265997108](E:\soft\Typora\img\1603265997108.png)

### 优点

并发收集、 低停顿， 一些官方公开文档里面也称之为“并发低停顿收集器” 

### 缺点

#### CMS收集器对处理器资源非常敏感 

在并发阶段， 它虽然不会导致用户线程停顿， 但却会因为占用了一部分线程（或者说处理器的计
算能力） 而导致应用程序变慢， 降低总吞吐量。 CMS默认启动的回收线程数是（处理器核心数量
+3） /4， 也就是说， 如果处理器核心数在四个或以上， 并发回收时垃圾收集线程只占用不超过25%的
处理器运算资源， 并且会随着处理器核心数量的增加而下降。 但是当处理器核心数量不足四个时，
CMS对用户程序的影响就可能变得很大。 如果应用本来的处理器负载就很高， 还要分出一半的运算能
力去执行收集器线程， 就可能导致用户程序的执行速度忽然大幅降低。  

#### CMS收集器无法处理“浮动垃圾”（Floating Garbage） 

在CMS的并发标记和并发清理阶段， 用户线程是还在继续运行的， 程序在运行自然就还会伴随有新的垃圾对象不断产生， 但这一部分垃圾对象是出现在标记过程结束以后， CMS无法在当次收集中处理掉它们， 只好留待下一次垃圾收集时再清理掉。  

#### CMS是一款基于“标记-清除”算法实现的收集器 ，收集结束时会有大量空间碎片产生 



## Garbage First收集器 

**Garbage First（简称G1） 收集器是垃圾收集器技术发展历史上的里程碑式的成果， 它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。**这个版本以后的G1收集器才被Oracle官方称为“全功能的垃圾收集
器”（Fully-Featured Garbage Collector） 。
G1是一款主要面向服务端应用的垃圾收集器。  JDK 9发布之日， **G1宣告取代Parallel Scavenge加Parallel Old组合， 成为服务端模式下的默认垃圾收集器， 而CMS则沦落至被声明为不推荐使用（Deprecate） 的收集器[1]。** 

### 停顿时间模型

停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内， 消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标， 

### Collection Set

 首先要有一个思想上的改变， 在G1收集器出现之前的所有其他收集器， 包括CMS在内， 垃圾收集的目标范围要么是整个新生代（Minor GC） ， 要么就是整个老年代（Major GC） ， 再要么就是整个Java堆（Full GC） 。 而G1跳出了这个樊笼， 它可以**面向堆内存任何部分来组成回收集**（Collection Set， 一般简称CSet） 进行回收， 衡量标准不再是它属于哪个分代， 而是哪块内存中存放的垃圾数量最多， 回收收益最大， 这就是G1收集器的Mixed GC模式。

### G1的分代

#### Region

**G1开创的基于Region的堆内存布局是它能够实现这个目标的关键**。 **G1不再坚持固定大小以及固定数量的**
**分代区域划分， 而是把连续的Java堆划分为多个大小相等的独立区域（Region） ， 每一个Region都可以**
**根据需要， 扮演新生代的Eden空间、 Survivor空间， 或者老年代空间。 收集器能够对扮演不同角色的**
**Region采用不同的策略去处理， 这样无论是新创建的对象还是已经存活了一段时间、 熬过多次收集的**
**旧对象都能获取很好的收集效果。**

#### Humongous区域

**Region中还有一类特殊的Humongous区域， 专门用来存储大对象**。 G1认为只要大小超过了一个
Region容量一半的对象即可判定为大对象。 每个Region的大小可以通过参数-XX： G1HeapRegionSize设
定， 取值范围为1MB～32MB， 且应为2的N次幂。 而对于那些超过了整个Region容量的超级大对象，
将会被存放在N个连续的Humongous Region之中， **G1的大多数行为都把Humongous Region作为老年代**
**的一部分来进行看待**
虽然G1仍然保留新生代和老年代的概念， 但新生代和老年代不再是固定的了， 它们都是一系列区
域（不需要连续） 的动态集合。 G1收集器之所以能建立可预测的停顿时间模型， 是因为它将Region作
为单次回收的最小单元， 即**每次收集到的内存空间都是Region大小的整数倍， 这样可以有计划地避免**
**在整个Java堆中进行全区域的垃圾收集**。

 **具体的处理思路**是<u>让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小， 价值即回收所获得的空间大小以及回收所需时间的经验值， 然后在后台维护一个优先级列表， 每次根据用户设定允许的收集停顿时间（使用参数-XX： MaxGCPauseMillis指定， 默认值是200毫秒） ， 优先处理回收价值收益最大的那些Region， 这也就是“Garbage First”名字的由来。这种使用Region划分内存空间， 以及具有优先级的区域回收方式， 保证了G1收集器在有限的时间内获取尽可能高的收集效率</u> 

![1603267222706](E:\soft\Typora\img\1603267222706.png)

#### G1的实现难点

#### 跨Region引用对象

解决的思路我们已经知道 ： **使用记忆集避免全堆作为GC Roots扫描**， 但在G1收集器上记
忆集的应用其实要复杂很多， 它的每个Region都维护有自己的记忆集， 这些记忆集会记录下别的Region
指向自己的指针， 并标记这些指针分别在哪些卡页的范围之内。 G1的记忆集在存储结构的本质上是一
种哈希表， Key是别的Region的起始地址， Value是一个集合， 里面存储的元素是卡表的索引号。 这
种“双向”的卡表结构（卡表是“我指向谁”， 这种结构还记录了“谁指向我”） 比原来的卡表实现起来更
复杂， 同时由于Region数量比传统收集器的分代数量明显要多得多， 因此G1收集器要比其他的传统垃
圾收集器有着更高的内存占用负担。 根据经验， **G1至少要耗费大约相当于Java堆容量10%至20%的额**
**外内存来维持收集器工作。**

#### 不干扰

譬如， 在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？ 这里首先要解决的是用户
线程改变对象引用关系时， 必须保证其不能打破原本的对象图结构， 导致标记结果出现错误， 该问题
的解决办法笔者已经抽出独立小节来讲解过（见3.4.6节） ： CMS收集器采用增量更新算法实现， 而G1
收集器则是通过原始快照（SATB） 算法来实现的。 此外， 垃圾收集对用户线程的影响还体现在回收过
程中新创建对象的内存分配上， 程序要继续运行就肯定会持续有新对象被创建， G1为每一个Region设
计了两个名为TAMS（Top at Mark Start） 的指针， 把Region中的一部分空间划分出来用于并发回收过
程中的新对象分配， 并发回收时新分配的对象地址都必须要在这两个指针位置以上。 G1收集器默认在
这个地址以上的对象是被隐式标记过的， 即默认它们是存活的， 不纳入回收范围。 与CMS中
的“Concurrent Mode Failure”失败会导致Full GC类似， 如果内存回收的速度赶不上内存分配的速度，
G1收集器也要被迫冻结用户线程执行， 导致Full GC而产生长时间“Stop The World”。

#### 停顿预测模型

·譬如， 怎样建立起可靠的停顿预测模型？ 用户通过-XX： MaxGCPauseMillis参数指定的停顿时间
只意味着垃圾收集发生之前的期望值， 但G1收集器要怎么做才能满足用户的期望呢？ G1收集器的停顿
预测模型是以衰减均值（Decaying Average） 为理论基础来实现的， 在垃圾收集过程中， G1收集器会记
录每个Region的回收耗时、 每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本， 并分析得
出平均值、 标准偏差、 置信度等统计信息。 这里强调的“衰减平均值”是指它会比普通的平均值更容易
受到新数据的影响， 平均值代表整体平均状态， 但衰减平均值更准确地代表“最近的”平均状态。 换句
话说， Region的统计状态越新越能决定其回收的价值。 然后通过这些信息预测现在开始回收的话， 由
哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。

### 运行过程

如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作） ， G1收集器的
运作过程大致可划分为以下四个步骤：
**·初始标记（Initial Marking）** ： 仅仅只是标记一下GC Roots能直接关联到的对象， 并且修改TAMS
指针的值， 让下一阶段用户线程并发运行时， 能正确地在可用的Region中分配新对象。 这个阶段需要
**停顿线程**， 但耗时很短， 而且是借用进行Minor GC的时候同步完成的， 所以G1收集器在这个阶段实际
并没有额外的停顿。
**·并发标记（Concurrent Marking**） ： 从GC Root开始对堆中对象进行可达性分析， 递归扫描整个堆
里的对象图， 找出要回收的对象， 这阶段耗时较长， 但可与用户程序并发执行。 当对象图扫描完成以
后， 还要重新处理SATB记录下的在并发时有引用变动的对象。
**·最终标记（Final Marking）** ： 对用户线程做另一个**短暂的暂停**， 用于处理并发阶段结束后仍遗留
下来的最后那少量的SATB记录。
**·筛选回收（Live Data Counting and Evacuation）** ： 负责更新Region的统计数据， 对各个Region的回
收价值和成本进行排序， 根据用户所期望的停顿时间来制定回收计划， 可以自由选择任意多个Region
构成回收集， 然后把决定回收的那一部分Region的存活对象复制到空的Region中， 再清理掉整个旧
Region的全部空间。 这里的操作涉及存活对象的移动， 是必须暂停用户线程， 由多条收集器线程并行
完成的。
从上述阶段的描述可以看出， G1收集器除了并发标记外， 其余阶段也是要完全暂停用户线程的，
换言之， 它并非纯粹地追求低延迟， 官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐
量， 所以才能担当起“全功能收集器”的重任与期望[4]。
从Oracle官方透露出来的信息可获知， 回收阶段（Evacuation） 其实本也有想过设计成与用户程序
一起并发执行， 但这件事情做起来比较复杂， 考虑到G1只是回收一部分Region， 停顿时间是用户可控
制的， 所以并不迫切去实现， 而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）
中。 另外， 还考虑到G1不是仅仅面向低延迟， 停顿用户线程能够最大幅度提高垃圾收集效率， 为了保
证吞吐量所以才选择了完全暂停用户线程的实现方案。 通过图3-13可以比较清楚地看到G1收集器的运
作步骤中并发和需要停顿的阶段 

![1603267267634](E:\soft\Typora\img\1603267267634.png)

**从G1开始， 最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率**
**（Allocation Rate） ， 而不追求一次把整个Java堆全部清理干净。 这样， 应用在分配， 同时收集器在收**
**集， 只要收集的速度能跟得上对象分配的速度， 那一切就能运作得很完美。 这种新的收集器设计思路**
**从工程实现上看是从G1开始兴起的， 所以说G1是收集器技术发展的一个里程碑。**

### 对比CMS收集器

G1收集器常会被拿来与CMS收集器互相比较， 毕竟它们都非常关注停顿时间的控制， 官方资料
[5]中将它们两个并称为“The Mostly Concurrent Collectors”。 在未来， G1收集器最终还是要取代CMS
的， 而当下它们两者并存的时间里， 分个高低优劣就无可避免。
相比CMS， G1的优点有很多， 暂且不论可以指定最大停顿时间、 分Region的内存布局、 按收益动
态确定回收集这些创新性设计带来的红利， 单从最传统的算法理论上看， G1也更有发展潜力。 与CMS
的“标记-清除”算法不同， **G1从整体来看是基于“标记-整理”算法实现的收集器， 但从局部（两个Region**
**之间） 上看又是基于“标记-复制”算法实现**， 无论如何， 这两种算法都意味着G1运作期间不会产生内存
空间碎片， 垃圾收集完成之后能提供规整的可用内存。 这种特性有利于程序长时间运行， 在程序为大
对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。
不过， G1相对于CMS仍然不是占全方位、 压倒性优势的， 从它出现几年仍不能在所有应用场景中
代替CMS就可以得知这个结论。 比起CMS， G1的弱项也可以列举出不少， 如在用户程序运行过程
中， **G1无论是为了垃圾收集产生的内存占用（Footprint） 还是程序运行时的额外执行负载**
**（Overload） 都要比CMS要高。**
就内存占用来说， 虽然G1和CMS都使用卡表来处理跨代指针， 但G1的卡表实现更为复杂， 而且
堆中每个Region， 无论扮演的是新生代还是老年代角色， 都必须有一份卡表， 这导致G1的记忆集（和
其他内存消耗） 可能会占整个堆容量的20%乃至更多的内存空间； 相比起来CMS的卡表就相当简单，
只有唯一一份， 而且只需要处理老年代到新生代的引用， 反过来则不需要， 由于新生代的对象具有朝
生夕灭的不稳定性， 引用变化频繁， 能省下这个区域的维护开销是很划算的[6]。
在执行负载的角度上， 同样由于两个收集器各自的细节实现特点导致了用户程序运行时的负载会
有不同， 譬如它们都使用到写屏障， CMS用写后屏障来更新维护卡表； 而G1除了使用写后屏障来进行
同样的（由于G1的卡表结构复杂， 其实是更烦琐的） 卡表维护操作外， 为了实现原始快照搜索
（SATB） 算法， 还需要使用写前屏障来跟踪并发时的指针变化情况。 相比起增量更新算法， 原始快照
搜索能够减少并发标记和重新标记阶段的消耗， 避免CMS那样在最终标记阶段停顿时间过长的缺点，
但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。 由于G1对写屏障的复杂操作
要比CMS消耗更多的运算资源， 所以CMS的写屏障实现是直接的同步操作， 而G1就不得不将其实现
为类似于消息队列的结构， 把写前屏障和写后屏障中要做的事情都放到队列里， 然后再异步处理。
以上的优缺点对比仅仅是针对G1和CMS两款垃圾收集器单独某方面的实现细节的定性分析， 通常
我们说哪款收集器要更好、 要好上多少， 往往是针对具体场景才能做的定量比较。 按照笔者的实践经
验， 目前在小内存应用上CMS的表现大概率仍然要会优于G1， 而在大内存应用上G1则大多能发挥其
优势， 这个优劣势的Java堆容量平衡点通常在6GB至8GB之间， 当然， 以上这些也仅是经验之谈， 不
同应用需要量体裁衣地实际测试才能得出最合适的结论， 随着HotSpot的开发者对G1的不断优化， 也
会让对比结果继续向G1倾斜。 

