### 对象的创建

Java是一门面向对象的编程语言， Java程序运行过程中无时无刻都有对象被创建出来。 在语言层面
上， 创建对象通常（例外： 复制、 反序列化） 仅仅是一个new关键字而已， 而在虚拟机中， **对象（文
中讨论的对象限于普通Java对象， 不包括数组和Class对象等） 的创建又是怎样一个过程呢**  

- 当Java虚拟机遇到一条字节码new指令时， 首先将去检查这个指令的参数是否能在常量池中定位到
  一个类的符号引用  
- 检查这个符号引用代表的类是否已被加载、 解析和初始化过。 如果没有， 那
  必须先执行相应的类加载过程，  
- 在类加载检查通过后  ，接下来虚拟机将为新生对象分配内存  对象所需内存的大小在类加载完成
  后便可完全确定（如何确定将在2.3.2节中介绍） ， 为对象分配空间的任务实际上便等同于把一块确定
  大小的内存块从Java堆中划分出来。   
  - 指针碰撞  ：假设Java堆中内存是绝对规整的， 所有被使用过的内存都被放在一
    边， 空闲的内存被放在另一边， 中间放着一个指针作为分界点的指示器， 那所分配内存就仅仅是把那
    个指针向空闲空间方向挪动一段与对象大小相等的距离， 
  - 空闲列表  ：但如果Java堆中的内存并不是规整的， 已被使用的内存和空闲的内存相互交错在一起， 那
    就没有办法简单地进行指针碰撞了， 虚拟机就必须维护一个列表， 记录上哪些内存块是可用的， 在分
    配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录，  
- 内存分配完成之后， 虚拟机必须将分配到的内存空间（但不包括对象头） 都初始化为零值， 如果
  使用了TLAB的话， 这一项工作也可以提前至TLAB分配时顺便进行。  
- 接下来， Java虚拟机还要对对象进行必要的设置， 例如这个对象是哪个类的实例、 如何才能找到
  类的元数据信息、 对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才
  计算） 、 对象的GC分代年龄等信息。   
- 执行  Class文件中的<init>()方法--**构造函数**，new指令之后会接着执行<init>
  ()方法， 按照程序员的意愿对对象进行初始化， 这样一个真正可用的对象才算完全被构造出来  

### 对象的内存布局

在HotSpot虚拟机里， 对象在堆内存中的存储布局可以划分为三个部分： **对象头**（Header） 、 **实例**
**数据**（Instance Data） 和**对齐填充**（Padding） 。

#### 对象头

HotSpot虚拟机对象的**对象头部分包括两类信息**。 **第一类是用于存储对象自身的运行时数据**， 如哈
希码（HashCode） 、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等， 这部
分数据的长度在32位和64位的虚拟机（未开启压缩指针） 中分别为32个比特和64个比特， 官方称它
为“**Mark Word**”。 对象需要存储的运行时数据很多， 其实已经超出了32、 64位Bitmap结构所能记录的
最大限度， 但对象头里的信息是与对象自身定义的数据无关的额外存储成本， 考虑到虚拟机的空间效
率， Mark Word被设计成一个有着动态定义的数据结构， 以便在极小的空间内存储尽量多的数据， 根
据对象的状态复用自己的存储空间。 例如在32位的HotSpot虚拟机中， 如对象未被同步锁锁定的状态
下， Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码， 4个比特用于存储对象分代年
龄， 2个比特用于存储锁标志位， 1个比特固定为0， 在其他状态（轻量级锁定、 重量级锁定、 GC标
记、 可偏向） [1]下对象的存储内容如表2-1所示。  

![image-20200914211453832](G:\soft\Typora\img\image-20200914211453832.png)

**对象头的另外一部分是类型指针**， 即**对象指向它的类型元数据的指针， Java虚拟机通过这个指针**
**来确定该对象是哪个类的实例**。 并不是所有的虚拟机实现都必须在对象数据上保留类型指针， 换句话
说， 查找对象的元数据信息并不一定要经过对象本身， 这点我们会在下一节具体讨论。 此外， 如果对
象**是一个Java数组**， 那在**对象头中还必须有一块用于记录数组长度的数据**， 因为虚拟机可以通过普通
Java对象的元数据信息确定Java对象的大小， 但是如果数组的长度是不确定的， 将无法通过元数据中的
信息推断出数组的大小。

#### 实例数据  

实例数据部分是对象真正存储的有效信息， 即**我们在程序代码里面所定义的各种类型的字**
**段内容， 无论是从父类继承下来的， 还是在子类中定义的字段都必须记录起来**。 这部分的存储顺序会
受到虚拟机分配策略参数（-XX： FieldsAllocationStyle参数） 和字段在Java源码中定义顺序的影响。
HotSpot虚拟机默认的分配顺序为longs/doubles、 ints、 shorts/chars、 bytes/booleans、 oops（Ordinary
Object Pointers， OOPs） ， 从以上默认的分配策略中可以看到， 相同宽度的字段总是被分配到一起存
放， 在满足这个前提条件的情况下， 在父类中定义的变量会出现在子类之前。 如果HotSpot虚拟机的
+XX： CompactFields参数值为true（默认就为true） ， 那子类之中较窄的变量也允许插入父类变量的空
隙之中， 以节省出一点点空间。  

#### 对齐填充  

它仅仅起着**占位符的作用**。 由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍， 换句话说就是
任何对象的大小都必须是8字节的整数倍。 对象头部分已经被精心设计成正好是8字节的倍数（1倍或者
2倍） ， 因此， 如果对象实例数据部分没有对齐的话， 就需要通过对齐填充来补全。  

### 对象的访问定位  

#### 句柄访问

如果使用句柄访问的话， Java堆中将可能会划分出一块内存来作为句柄池， reference中存储的就
是对象的句柄地址， 而句柄中包含了对象实例数据与类型数据各自具体的地址信息， 其结构如图2-2所
示。

![image-20200914211920595](G:\soft\Typora\img\image-20200914211920595.png)

#### 直接指针访问

如果使用直接指针访问的话， Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关
信息， reference中存储的直接就是对象地址， 如果只是访问对象本身的话， 就不需要多一次间接访问
的开销， 如图2-3所示  



![image-20200914211935787](G:\soft\Typora\img\image-20200914211935787.png)

#### 两者比较

使用**句柄来访问的最大好处就是reference中存储的是稳定句柄地址**， 在对象被移动（垃圾收集时移动对象是非常普遍的行为） 时只会改变句柄中的实例数据指针， 而reference本身不需要被修改。  

使用**直接指针来访问最大的好处就是速度更快**， 它节省了一次指针定位的时间开销， **由于对象访**
**问在Java中非常频繁**， 因此这类开销积少成多也是一项极为可观的执行成本， **就本书讨论的主要虚拟**
**机HotSpot而言， 它主要使用第二种方式进行对象访问**  

