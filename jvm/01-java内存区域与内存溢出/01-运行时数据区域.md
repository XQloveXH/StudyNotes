### 运行时数据区域

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。 这些区域
有各自的用途， 以及创建和销毁的时间， 有的区域随着虚拟机进程的启动而一直存在， 有些区域则是
依赖用户线程的启动和结束而建立和销毁。 根据《Java虚拟机规范》 的规定， Java虚拟机所管理的内存
将会包括以下几个运行时数据区域， 如图2-1所示  

![image-20200914204006450](G:\soft\Typora\img\image-20200914204006450.png)

### 程序计数器

![image-20200917195219492](G:\soft\Typora\img\image-20200917195219492.png)

程序计数器（Program Counter Register） 是一块**较小的内存空间**， **它可以看作是当前线程所执行的**
**字节码的行号指示器**。 在Java虚拟机的概念模型里[1]， **字节码解释器**工作时就是通过改变这个计数器
的值来**选取下一条需要执行的字节码指令**， 它是程序控制流的指示器， 分支、 循环、 跳转、 异常处
理、 线程恢复等基础功能都需要依赖这个计数器来完成。

由于Java虚拟机的多线程是通过线程轮流切换、 分配处理器执行时间的方式来实现的， 在任何一
个确定的时刻， 一个处理器（对于多核处理器来说是一个内核） 都只会执行一条线程中的指令。 因
此， 为了线程切换后能恢复到正确的执行位置， **每条线程都需要有一个独立的程序计数器**， 各条线程
之间计数器互不影响， 独立存储， 我们称这类内存区域为“**线程私有**”的内存。

- 如果线程正在执行的是一个**Java方法**， 这个计数器记录的是**正在执行的虚拟机字节码指令的地**
  **址；**

-  如果正在执行的是， 这个计数器值则应为空（Undefined） 。 **此内存区域是唯**
    **一一个在《Java虚拟机规范》 中没有规定任何OutOfMemoryError情况的区域。**



### **java虚拟机栈**

与程序计数器一样， **Java虚拟机栈（Java Virtual Machine Stack） 也是线程私有的**， **它的生命周期**
**与线程相同**。 虚拟机栈描述的是Java方法执行的线程内存模型： **每个方法被执行的时候， Java虚拟机都**
**会同步创建一个栈帧[1]（Stack Frame） 用于存储局部变量表、 操作数栈、 动态连接、 方法出口等信**
**息。 每一个方法被调用直至执行完毕的过程， 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。**
经常有人把Java内存区域笼统地划分为堆内存（Heap） 和栈内存（Stack） ， 这种划分方式直接继
承自传统的C、 C++程序的内存布局结构， 在Java语言里就显得有些粗糙了， 实际的内存区域划分要比
这更复杂。 不过这种划分方式的流行也间接说明了程序员最关注的、 与对象内存分配关系最密切的区
域是“堆”和“栈”两块。 其中， “堆”在稍后笔者会专门讲述， **而“栈”通常就是指这里讲的虚拟机栈， 或**
**者更多的情况下只是指虚拟机栈中局部变量表部分。**

**局部变量表存放了编译期可知的各种Java虚拟机基本数据类型**（boolean、 byte、 char、 short、 int、
float、 long、 double） 、 **对象引用**（reference类型， 它并不等同于对象本身， 可能是一个指向对象起始
地址的引用指针， 也可能是指向一个代表对象的句柄或者其他与此对象相关的位置） 和**returnAddress**
类型（指向了一条字节码指令的地址） 。

这些数据类型在局部变量表中的存储空间以局部变量槽（Slot） 来表示， 其中64位长度的long和
double类型的数据会占用两个变量槽， 其余的数据类型只占用一个。 **局部变量表所需的内存空间在编**
**译期间完成分配， 当进入一个方法时， 这个方法需要在栈帧中分配多大的局部变量空间是完全确定**
**的， 在方法运行期间不会改变局部变量表的大小**。 请读者注意， 这里说的“大小”是指变量槽的数量，
虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、 64个比特， 或者更多） 来实现一
个变量槽， 这是完全由具体的虚拟机实现自行决定的事情。

在《Java虚拟机规范》 中， 对这个内存区域规定了两类异常状况： 如果线程请求的栈深度大于虚
拟机所允许的深度， 将抛出**StackOverflowError**异常； 如果Java虚拟机栈容量可以动态扩展[2]， 当栈扩
展时无法申请到足够的内存会抛出**OutOfMemoryError**异常。  

**注意**：**HotSpot虚拟机的栈容量是不可以动态扩展的**， 以前的Classic虚拟机倒是可以。 所以在HotSpot虚拟
机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不
会有OOM， 但是如果申请时就失败， 仍然是会出现OOM异常的， 后面的实战中笔者也演示了这种情
况。  

#### 线程异常诊断

- 用top定位哪个进程对cpu的占用过高
- ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）
- jstack 进程id
- 可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号  

### 本地方法栈

本地方法栈（Native Method Stacks） 与虚拟机栈所发挥的作用是非常相似的， 其区别只是**虚拟机**
**栈为虚拟机执行Java方法（也就是字节码） 服务**， **而本地方法栈则是为虚拟机使用到的本地（Native）**
**方法服务**  

### java堆

对于Java应用程序来说， **Java堆（Java Heap） 是虚拟机所管理的内存中最大的一块**。 Java堆是被所
有**线程共享**的一块内存区域， 在虚拟机启动时创建。 此内存区域的**唯一目的就是存放对象实例**， Java
世界里“几乎”所有的对象实例都在这里分配内存。 在《Java虚拟机规范》 中对Java堆的描述是： “所有
的对象实例以及数组都应当在堆上分配[1]”， 而这里笔者写的“几乎”是指从实现角度来看， 随着Java语
言的发展， 现在已经能看到些许迹象表明日后可能出现值类型的支持， 即使只考虑现在， 由于即时编
译技术的进步， 尤其是逃逸分析技术的日渐强大， 栈上分配、 标量替换[2]优化手段已经导致一些微妙
的变化悄然发生， 所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。

**Java堆是垃圾收集器管理的内存区域**， 因此一些资料中它也被称作“GC堆”（Garbage Collected
Heap， 幸好国内没翻译成“垃圾堆”） 。 从回收内存的角度看， 由于现代垃圾收集器大部分都是基于分
代收集理论设计的， 所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空
间”“To Survivor空间”等名词， 这些概念在本书后续章节中还会反复登场亮相， 在这里笔者想先说明的
是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已， 而非某个Java虚拟机具体
实现的固有内存布局， 更不是《Java虚拟机规范》 里对Java堆的进一步细致划分。 不少资料上经常写着
类似于“Java虚拟机的堆内存分为新生代、 老年代、 永久代、 Eden、 Survivor……”这样的内容。 在十年
之前（以G1收集器的出现为分界） ， **作为业界绝对主流的HotSpot虚拟机**， **它内部的垃圾收集器全部**
**都基于“经典分代”[3]来设计， 需要新生代、 老年代收集器搭配才能工作**， 在这种背景下， 上述说法还
算是不会产生太大歧义。 但是到了今天， 垃圾收集器技术与十年前已不可同日而语， HotSpot里面也出
现了不采用分代设计的新垃圾收集器， 再按照上面的提法就有很多需要商榷的地方了。

**如果从分配内存的角度看， 所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区**
（Thread Local Allocation Buffer， TLAB） ， **以提升对象分配时的效率**。 不过无论从什么角度， 无论如
何划分， 都不会改变Java堆中存储内容的共性， **无论是哪个区域， 存储的都只能是对象的实例**， 将Java
堆**细分的目的只是为了更好地回收内存**， 或者更快地**分配内存**。 在本章中， 我们仅仅针对内存区域的
作用进行讨论， Java堆中的上述各个区域的分配、 回收等细节将会是下一章的主题。
根据《Java虚拟机规范》 的规定， Java堆可以处于物理上不连续的内存空间中， 但在逻辑上它应该
被视为连续的， 这点就像我们用磁盘空间去存储文件一样， 并不要求每个文件都连续存放。 但对于大
对象（典型的如数组对象） ， 多数虚拟机实现出于实现简单、 存储高效的考虑， 很可能会要求连续的
内存空间。
Java堆既可以被实现成固定大小的， 也可以是可扩展的， 不过当前主流的Java虚拟机都是按照可扩
展来实现的（通过参数-Xmx和-Xms设定） 。 如果在Java堆中没有内存完成实例分配， 并且堆也无法再
扩展时， Java虚拟机将会抛出OutOfMemoryError异常。  

**经典分代**：指新生代（其中又包含一个Eden和两个Survivor） 、 老年代这种划分  



### 方法区

**方法区（Method Area） 与Java堆一样， 是各个线程共享的内存区域， 它用于存储已被虚拟机加载**
**的类型信息、 常量、 静态变量、 即时编译器编译后的代码缓存等数据。** 虽然《Java虚拟机规范》 中把
方法区描述为堆的一个逻辑部分， 但是它却有一个别名叫作“非堆”（Non-Heap） ， 目的是与Java堆区
分开来。  

说到方法区， 不得不提一下“永久代”这个概念， 尤其是在JDK 8以前， 许多Java程序员都习惯在
HotSpot虚拟机上开发、 部署程序， 很多人都更愿意把方法区称呼为“永久代”（Permanent
Generation） ，  考虑到HotSpot未来的发展， 在JDK 6的
时候HotSpot开发团队就有放弃永久代， 逐步改为采用本地内存（Native Memory） 来实现方法区的计
划了[1]， 到了JDK 7的HotSpot， 已经把原本放在永久代的字符串常量池、 静态变量等移出， 而到了
**JDK 8， 终于完全废弃了永久代的概念**， **改用与JRockit、 J9一样在本地内存中实现的元空间（Metaspace） 来代替， 把JDK 7中永久代还剩余的内容（主要是类型信息） 全部移到元空间中**。  

### 运行时常量池  

**运行时常量池（Runtime Constant Pool） 是方法区的一部分。 Class文件中除了有类的版本、 字**
**段、 方法、 接口等描述信息外， 还有一项信息是常量池表（Constant Pool Table） ， 用于存放编译期生**
**成的各种字面量与符号引用， 这部分内容将在类加载后存放到方法区的运行时常量池中。**  

运行时常量池相对于Class文件常量池的另外一个重要特征是**具备动态性**， Java语言并不要求常量
一定只有编译期才能产生， 也就是说， 并非预置入Class文件中常量池的内容才能进入方法区运行时常
量池， **运行期间也可以将新的常量放入池中**， 这种特性被开发人员利用得比较多的便是**String类的**
**intern()方法。**

既然运行时常量池是方法区的一部分， 自然受到方法区内存的限制， 当常量池无法再申请到内存
时会抛出OutOfMemoryError异常。 

#### 常量池与运行时常量池的区别

**常量池**，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量
等信息
**运行时常量池**，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量
池，并把里面的符号地址变为真实地址   

#### StringTable

##### 面试题

```java
String s1 = "a";
String s2 = "b";
String s3 = "a" + "b";
String s4 = s1 + s2;
String s5 = "ab";
String s6 = s4.intern();
// 问
System.out.println(s3 == s4);
System.out.println(s3 == s5);
System.out.println(s3 == s6);
String x2 = new String("c") + new String("d");
String x1 = "cd";
x2.intern();
// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢
System.out.println(x1 == x2);
```

##### StringTable 特性

- 常量池中的字符串仅是符号，第一次用到时才变为对象
- 利用串池的机制，来避免重复创建字符串对象
- 字符串变量拼接的原理是 StringBuilder （1.8）
- 字符串常量拼接的原理是编译期优化
- 可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池
  - 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串
    池中的对象返回
  - 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，
    放入串池， 会把串池中的对象返回  



##### StringTable位置

![1603278530200](E:\soft\Typora\img\1603278530200.png)



##### StringTable的调优

**StringTable底层是用的HashTable的数据结构实现，即拉链法。因此数组越大hash冲突越少，存储效率越高。**

测试代码

```java
package cn.itcast.jvm.t1.stringtable;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 演示串池大小对性能的影响
 * -Xms500m -Xmx500m -XX:+PrintStringTableStatistics -XX:StringTableSize=1009
 */
public class Demo1_24 {

    public static void main(String[] args) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream("linux.words"), "utf-8"))) {
            String line = null;
            long start = System.nanoTime();
            while (true) {
                line = reader.readLine();
                if (line == null) {
                    break;
                }
                line.intern();
            }
            System.out.println("cost:" + (System.nanoTime() - start) / 1000000);
        }


    }
}

```

- 当-XX:StringTableSize=1009时，程序耗时为

  ![image-20200919135733004](G:\soft\Typora\img\image-20200919135733004.png)

- 当-XX:StringTableSize=200000时，程序耗时为

​     ![](G:\soft\Typora\img\image-20200919135623661.png)

### 直接内存  

直接内存（Direct Memory） 并不是虚拟机运行时数据区的一部分， 也不是《Java虚拟机规范》 中
定义的内存区域。 但是这部分内存也被频繁地使用， 而且也可能导致OutOfMemoryError异常出现， 所
以我们放到这里一起讲解。

**在JDK 1.4中新加入了NIO（New Input/Output） 类， 引入了一种基于通道（Channel） 与缓冲区**
**（Buffer） 的I/O方式， 它可以使用Native函数库直接分配堆外内存， 然后通过一个存储在Java堆里面的**
**DirectByteBuffer对象作为这块内存的引用进行操作。 这样能在一些场景中显著提高性能， 因为避免了**
**在Java堆和Native堆中来回复制数据。**

显然， 本机直接内存的分配不会受到Java堆大小的限制， 但是， 既然是内存， 则肯定还是会受到
本机总内存（包括物理内存、 SWAP分区或者分页文件） 大小以及处理器寻址空间的限制， 一般服务
器管理员配置虚拟机参数时， 会根据实际内存去设置-Xmx等参数信息， 但经常忽略掉直接内存， 使得
各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制） ， 从而导致动态扩展时出现
OutOfMemoryError异常  

## JDK1.6，1.7，1.8的变化

![1603278047987](E:\soft\Typora\img\1603278047987.png)

![1603278078055](E:\soft\Typora\img\1603278078055.png)![1603278119062](E:\soft\Typora\img\1603278119062.png)