# 概述 

**执行引擎是Java虚拟机核心的组成部分之一**。 “虚拟机”是一个相对于“物理机”的概念， 这两种机
器都有代码执行能力， 其区别是物理机的执行引擎是直接建立在处理器、 缓存、 指令集和操作系统层
面上的， 而虚拟机的执行引擎则是由软件自行实现的， 因此可以不受物理条件制约地定制指令集与执
行引擎的结构体系， 能够执行那些不被硬件直接支持的指令集格式。

在《Java虚拟机规范》 中制定了Java虚拟机字节码执行引擎的概念模型， 这个概念模型成为各大发
行商的Java虚拟机执行引擎的统一外观（Facade） 。 在不同的虚拟机实现中， 执行引擎在执行字节码的
时候， 通常会有解释执行（通过解释器执行） 和编译执行（通过即时编译器产生本地代码执行） 两种
选择[1]， 也可能两者兼备， 还可能会有同时包含几个不同级别的即时编译器一起工作的执行引擎。 但
**从外观上来看， 所有的Java虚拟机的执行引擎输入、 输出都是一致的： 输入的是字节码二进制流， 处**
**理过程是字节码解析执行的等效过程， 输出的是执行结果**， 本章将主要从概念模型的角度来讲解虚拟
机的方法调用和字节码执行。 

# 运行时栈帧结构 

- **每一个栈帧都包括了局部变量表、 操作数栈、 动态连接、 方法返回地址和一些额外的附加信息。** 

- **一个栈帧需要分配多少内存， 并不会受到程序运行期变量数据的影响， 而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式 。**

- **在编译Java程序源码的时候， 栈帧中需要多大的局部变量表， 需要多深的操作数栈就已经被分析计算出来， 并且写入到方法表的Code属性之中[2]。**  

**当前栈帧：在活动线程中， 只有位于栈顶的方法才是在运行的， 只有位于栈顶的栈帧才是生效的 **

**当前方法：与当前栈帧相关联的方法**

![1604799634045](E:\soft\Typora\img\1604799634045.png)

# 局部变量表 

**局部变量表**（Local Variables Table） 是**一组变量值的存储空间， 用于存放方法参数和方法内部定义**
**的局部变量。**

 在Java程序被编译为Class文件时， 就在方法的**Code属性的max_locals**数据项中确定了该方
法所需**分配的局部变量表的最大容量**。 

## 变量槽（slot）

**局部变量表的容量以变量槽（Variable Slot） 为最小单位** 

### 大小

《Java虚拟机规范》 中并没有明确指出一个变量槽应占用的内存空间大小， 只是很有导向性地说到每个变量槽都应该能存放一个boolean、byte、 char、 short、 int、 float、 reference或returnAddress类型的数据。

### 64位数据类型的存储和访问

**对于64位的数据类型， Java虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间。** 

Java语言中明确的64位的数据类型只有long和double两种 

#### 分割存储 

把long和double数据类型分割存储的做法与“long和double的非原子性协定”中**允许把一次long和double数据类读写分割为两次32位读写的做法有些类似** 

#### 安全问题

**由于局部变量表是建立在线程堆栈中的， 属于线程私有的数据， 无论读写两个连续的变量槽是否为原子操作， 都不会引起数据竞争和线程安全问题。** 







## 数据类型

### reference类型 

**reference类型表示对一个对象实例的引用**， 《Java虚拟机规范》 既没有说明它的长度， 也没有明确指出这种引用应有怎样的结构。 但是一般来说， **虚拟机实现至少都应当能通过这个引用做到两件事情**：

- **根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引** 
- **根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息** 

### returnAddress类型 

returnAddress类型目前已经很少见了， **它是为字节码指令jsr、 jsr_w和ret服务的**， 指向了一条字节码指令的地址， 某些很**古老的Java虚拟机**曾经使用这几条指令来**实现异常处理时的跳转**， 但**现在也已经全部改为采用异常表**来代替了。 

## 访问方式

- Java虚拟机通过索引定位的方式使用局部变量表， 索引值的范围是从0开始至局部变量表最大的变量槽数量。 
  - 如果访问的是32位数据类型的变量， 索引N就代表了使用第N个变量槽
  - 如果访问的是64位
    数据类型的变量， 则说明会同时使用第N和N+1两个变量槽。 对于两个相邻的共同存放一个64位数据的两个变量槽， **虚拟机不允许采用任何方式单独访问其中的某一个** 。如果遇到进行这种操作的字节码序列， 如果遇到进行这种操作的字节码序列， **虚拟机就应该在类加载的校验阶段中抛出异常**。 

- 当一个方法被调用时， Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。  
  - 如果执行的是**实例方法**（没有被static修饰的方法） ， 那**局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用**， 在方法中可以通过关键字“this”来访问到这个隐含的参数。  
- 局部变量表中的变量槽是可以重用的 
  - 方法体中定义的变量， 其作用域并不一定会覆盖整个方法体， 如果当前字节码PC计数器的值已经超出了某个变量的作用域， 那这个变量对应的变量槽就可以交给其他变量来重用。  

## 局部变量的初始值

**局部变量不像前面介绍的类变量那样存在“准备阶段”** 

类的字段变量有两次赋初始值的过程 ：

- 一次在准备阶段， 赋予系统初始值；  （特殊情况：Constvalue属性的初始值）
- 另外一次在初始化阶段， 赋予程序员定义的初始值。 （调用<clinit>（）初始化类变量

**如果一个局部变量定义了但没有赋初始值， 那它是完全不能使用的** 

**字节码校验的时候也会被虚拟机发现而导致类加载失败** 

# 操作数栈

操作数栈（Operand Stack） 也常被称为操作栈， 它是一个后入先出（Last In First Out， LIFO）栈。  

操作数栈的最大深度也在编译的时候被写入到**Code属性的max_stacks**数据项之中。  

32位数据类型所占的栈容量为1， 64位数据类型所占的栈容量为2 。

当一个方法刚刚开始执行的时候， 这个方法的操作数栈是空的， **在方法的执行过程中， 会有各种字节码指令往操作数栈中写入和提取内容， 也就是出栈和入栈操作**。 

![1604801604640](E:\soft\Typora\img\1604801604640.png)

# 动态连接 

**每个栈帧都包含一个指向运行时常量池[1]中该栈帧所属方法的引用， 持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）**  

Class文件的常量池中存有大量的符号引用， **字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数** 

**静态解析** :这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用

**动态连接** :在每一次运行期间都转化为直接引用 

# 方法返回地址 

当一个方法开始执行后， 只有两种方式退出这个方法 。一般来说， 方法正常退出时， 主调方法的PC计数器的值就可以作为返回地址， 栈帧中很可能会保存这个计数器值。 而方法异常退出时， 返回地址是要通过异常处理器表来确定的， 栈帧中就一般不会保存这部分信息。 

## 正常调用完成 

执行引擎遇到任意一个方法返回的字节码指令， 这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者或者主调方法） ， 方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定， 这种退出方法的方式称为“正常调用完成”（Normal Method Invocation Completion） 。 

## 异常调用完成 

在方法执行的过程中遇到了异常， 并且这个异常没有在方法体内得到妥善处理。 无论是Java虚拟机内部产生的异常， 还是代码中使用athrow字节码指令产生的异常， 只要在本方法的异常表中没有搜索到匹配的异常处理器， 就会导致方法退出， 这种退出方法的方式称为“异常调用完成（Abrupt Method Invocation Completion） ”。  

**方法使用异常完成出口的方式退出， 是不会给它的上层调用者提供任何返回值的。** 

## 出栈过程的可能操作

- 恢复上层方法的局部变量表和操作数栈 
- 把返回值（如果有的话） 压入调用者栈帧的操作数栈中 
- 调整PC计数器的值以指向方法调用指令后面的一条指令等 

“可能”是由于这是基于概念模型的讨论， 只有具体到某一款Java虚拟机实现， 会执行哪些操作才能确定下来。 



