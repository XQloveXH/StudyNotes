

# java内存模型

**Java内存模型规定了所有的变量都存储在主内存**（Main Memory） 中（此处的主内存与介绍物理
硬件时提到的主内存名字一样， 两者也可以类比， 但物理上它仅是虚拟机内存的一部分） 。 **每条线程**
**还有自己的工作内存（Working Memory， 可与前面讲的处理器高速缓存类比） ， 线程的工作内存中保**
**存了被该线程使用的变量的主内存副本[2]， 线程对变量的所有操作（读取、 赋值等） 都必须在工作内**
**存中进行， 而不能直接读写主内存中的数据**[3]。 **不同的线程之间也无法直接访问对方工作内存中的变**
**量， 线程间变量值的传递均需要通过主内存来完成**， 线程、 主内存、 工作内存三者的交互关系如图12-
2所示， 注意与图12-1进行对比。 

![1605177843632](E:\soft\Typora\img\1605177843632.png)

[1] 此处请读者注意区分概念： **如果局部变量是一个reference类型， 它引用的对象在Java堆中可被各个**
**线程共享， 但是reference本身在Java栈的局部变量表中是线程私有的**。
[2] 有部分读者会对这段描述中的“副本”提出疑问， 如“**假设线程中访问一个10MB大小的对象， 也会把**
**这10MB的内存复制一份出来吗**？ ”， 事实上并不会如此， 这**个对象的引用、 对象中某个在线程访问到**
**的字段是有可能被复制的， 但不会有虚拟机把整个对象复制一次**。
[3] 根据《Java虚拟机规范》 的约定， volatile变量依然有工作内存的拷贝， 但是由于它特殊的操作顺序
性规定（后文会讲到） ， 所以看起来如同直接在主内存中读写访问一般， 因此这里的描述对于volatile
也并不存在例外。
[4] 除了**实例数据**， Java堆还保存了对象的其他信息， 对于HotSpot虚拟机来讲， 有**Mark Word**（存储对
象哈希码、 GC标志、 GC年龄、 同步锁等信息） 、 **Klass Point**（指向存储类型元数据的指针） 及一些**用**
**于字节对齐补白的填充数据**（如果实例数据刚好满足8字节对齐， 则可以不存在补白） 

# 内存间交互操作 

- lock（锁定） ： **作用于主内存的变量， 它把一个变量标识为一条线程独占的状态**。
- unlock（解锁） ： 作用于主内存的变量， 它把一个处于锁定状态的变量释放出来， 释放后的变量
  才可以被其他线程锁定。
- read（读取） ： 作用于主内存的变量， 它把一个变量的值从主内存传输到线程的工作内存中， 以
  便随后的load动作使用。
- load（载入） ： 作用于工作内存的变量， 它把read操作从主内存中得到的变量值放入工作内存的
  变量副本中。
- use（使用） ： 作用于工作内存的变量， 它把工作内存中一个变量的值传递给执行引擎， 每当虚
  拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- assign（赋值） ： 作用于工作内存的变量， 它把一个从执行引擎接收的值赋给工作内存的变量，
  每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store（存储） ： 作用于工作内存的变量， 它把工作内存中一个变量的值传送到主内存中， 以便随
  后的write操作使用。
- write（写入） ： 作用于主内存的变量， 它把store操作从工作内存中得到的变量的值放入主内存的
  变量中。 

# Java内存模型的访问协议 

- 不允许read和load、 store和write操作之一单独出现， 即**不允许一个变量从主内存读取了但工作内**
  **存不接受， 或者工作内存发起回写了但主内存不接受的情况出现**。
- 不允许一个线程丢弃它最近的assign操作， 即**变量在工作内存中改变了之后必须把该变化同步回**
  **主内存**。
- **不允许一个线程无原因地（没有发生过任何assign操作） 把数据从线程的工作内存同步回主内存**
  **中**。
- 一个新的变量只能在主内存中“诞生”， 不允许在工作内存中直接使用一个未被初始化（load或
  assign） 的变量， 换句话说就是**对一个变量实施use、 store操作之前， 必须先执行assign和load操作**。
- **一个变量在同一个时刻只允许一条线程对其进行lock操作**， **但lock操作可以被同一条线程重复执**
  **行多次， 多次执行lock后， 只有执行相同次数的unlock操作， 变量才会被解锁**。
- **如果对一个变量执行lock操作， 那将会清空工作内存中此变量的值， 在执行引擎使用这个变量**
  **前， 需要重新执行load或assign操作以初始化变量的值。**
- 如果一个变量事先没有被lock操作锁定， 那就不允许对它执行unlock操作， 也不允许去unlock一个
  被其他线程锁定的变量。
- 对**一个变量执行unlock操作之前， 必须先把此变量同步回主内存中**（执行store、 write操作

# 原子性、可见性、有序性

**原子性 - 保证指令不会受到线程上下文切换的影响**
**可见性 - 保证指令不会受 cpu 缓存的影响**
**有序性 - 保证指令不会受 cpu 指令并行优化的影响** 

java内存模型是围绕着在并发过程中如何处理原子性、可见性、有序性这3个特征来建立的。

## 原子性

#### 定义：

原子性：是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么就都不执行。

#### 原子操作原理（处理器是如何实现原子操作的）

处理器实现原子操作有3种方式：

**1. 处理器自动保证基本内存操作的原子性**

首先说明，处理器会自动保证**基本的内存操作是原子性的**。处理器保证从系统内存中读取或写入一个字节是原子的。意思是，当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。

当然，`long`和`double`类型在32位操作系统中的读写操作不是原子的，因为`long`和`double`占64位，需要分成2个步骤来处理，在读写时分别拆成2个字节进行读写。因此`long`和`double`类型的数据在进行计算时需要注意这个问题。

**2. 使用总线锁保证原子性**

如果多个处理器同时对共享变量进行读改写操作（如：i++）,共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的。

当多个处理器调度线程时，同时读取主内存中的共享变量，就会造成上面的问题。如果想上述操作是原子的，那么必须保证CPU1读改写共享变量时，CPU2不能做缓存该共享变量的操作。

处理器使用总线锁就是解决这个问题的。**总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占使用共享内存**。

**java锁机制其实是锁总线**。

**3. 使用缓存锁保证原子性**

总线锁把CPU和内存之间通信锁住，使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁的开销比较大。所以在某些场合使用缓存锁替代总线锁。

**缓存锁是指通过锁住CPU缓存，在CPU缓存区实现共享变量的原子性操作**。

如果缓存在处理器的缓存行中，内存区域在LOCK操作期间被锁定，当它执行锁操作，回写主内存时，处理器不在总线锁上声言LOCK#信号，而是修改内部内存地址，并允许它的缓存一致性机制来保证操作的原子性。因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效。

缓存锁使用的是**比较并交换策略（Compare And Swap简称CAS）**，CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。

**java并发包中的原子类就是使用缓存锁机制**。

在两种情况下处理器不会使用缓存锁。

- 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line），则处理器会调用总线锁定。
- 有些处理器不支持缓存锁定。
- CPU 缓存结构原理 

## 可见性

#### 定义：

可见性是指：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。

Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的，无论是普通变量还是volatile变量都是如此。

**普通变量与volatile变量的区别**
是volatile的特殊规则保证了新值能立即同步到主内存，以及每使用前立即从内存刷新。因为我们可以说volatile保证了线程操作时变量的可见性，而普通变量则不能保证这一点。

## 有序性

**有序性：即程序执行的顺序按照代码的先后顺序执行。**

Java内存模型中的程序天然有序性可以总结为一句话：**如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的**。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。

有序性的语意有几层，
\1. 最常见的就是保证多线程运行的串行顺序
\2. 防止重排序引起的问题
\3. 程序运行的先后顺序。比方JMM定义的一些Happens-before规则

# CPU 缓存结构原理 

## CPU 缓存结构 

## CPU 缓存读 

## CPU 缓存一致性 

# volatile型变量

volatile的特殊规则保证了volatile变量的可见性和有序性。

## volatile关键字介绍

在java中提供了volatile关键字，通过volatile关键字修饰内存中的变量，该变量在线程之间共享。

volatile关键字是轻量级的锁（synchronized）。在使用的时候，消耗的成本比synchronized小很多。volatile用于修饰变量。

## volatile实现原理（如何保证可见性和有序性）

### 从指令级别上理解

volatile修饰的变量，在翻译成汇编语言的时候，会有一个LOCK前缀的指令。

LOCK前缀的指令在多核处理器下会引发两件事情。

1. 将当期处理器缓存行的数据会写回到系统内存。
2. 这个写回内存的操作会引起在其他CPU里缓存该内存地址的数据无效。

如果对声明了volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现**缓存一致性协议**，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。

### 从内存屏障上理解

#### 可见性

写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中
而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据

#### 有序性

写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后
读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前 

## volatile的适用范围

volatile变量固然方便，但是存在着限制，volatile修饰的变量，并不能保证是原子操作的，所以多处理器操作数据时，会导致数据重复。所以**volatile关键字通常被当作完成、中断的状态的标识使用**。

## final关键字的可见性

与volatile相比较，final域的读和写更像是普通的变量访问。

对于final域，编译器和处理器要遵守两个重排序规则：

1. 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

2. 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序

   - 写final域的重排序规则

     - JMM禁止编译器把final域的写重排序到构造函数之外。

     - 编译器会在final域的写之后，构造函数return之前，插入一个**StoreStore屏障**。这个屏障禁止处理器把final域的写重排序到构造函数之外。

   - 读final域的重排序规则

     - 在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。

# volatile的应用--双重检查模式

以著名的 double-checked locking 单例模式为例 

![1605183533315](E:\soft\Typora\img\1605183533315.png)

以上的实现特点是：

- 懒惰实例化
- 首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁
- 有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外 

但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为

```0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
3: ifnonnull 37
6: ldc #3 // class cn/itcast/n5/Singleton
8: dup
9: astore_0
10: monitorenter
11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
14: ifnonnull 27
17: new #3 // class cn/itcast/n5/Singleton
20: dup
21: invokespecial #4 // Method "<init>":()V
24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
27: aload_0
28: monitorexit
29: goto 37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
40: areturn 
```

- 17 表示创建对象，将对象引用入栈 // new Singleton
- 20 表示复制一份对象引用 // 引用地址
- 21 表示利用一个对象引用，调用构造方法
- 24 表示利用一个对象引用，赋值给 static INSTANCE 

也许 jvm 会优化为：**先执行 24，再执行 21**。如果两个线程 t1，t2 按如下时间序列执行： 

![1605183721091](E:\soft\Typora\img\1605183721091.png)

关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取
INSTANCE 变量的值
**这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例**
对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效

## volatile修饰后

**lock指令会把修改同步到内存当中，所有之前的操作都已经执行完毕，这样便形成了指令重排序无法越过内存屏障的效果**，换句话说写指令之前的指令是无法在写指令之后执行的也就是常说的写屏障。